{"ast":null,"code":"function e(e, t, n) {\n  let r = [d.run({\n    fn: e => t(e)\n  })];\n\n  if (n) {\n    let t = y({\n      node: r\n    }),\n        o = e.graphite.id,\n        u = n.additionalLinks,\n        a = u[o] || [];\n    return u[o] = a, a.push(t), () => {\n      let e = a.indexOf(t);\n      -1 !== e && a.splice(e, 1), k(t);\n    };\n  }\n\n  {\n    let t = y({\n      node: r,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return () => {\n      k(t);\n    };\n  }\n}\n\nfunction t(e, t) {\n  return t.displayName = e, t;\n}\n\nfunction n(t, n) {\n  v.store(t) || S('expect useStore argument to be a store');\n  let r = w(t, n),\n      o = N(),\n      u = m.useRef({\n    store: t,\n    value: r,\n    pending: 0\n  });\n  return b(() => {\n    let r = e(t, e => {\n      let t = u.current;\n      t.pending || (t.value = e, t.pending = 1, o(), t.pending = 0);\n    }, n),\n        a = w(t, n),\n        s = u.current;\n    return s.store === t && s.value !== a && (s.value = a, s.pending = 1, o(), s.pending = 0), s.store = t, r;\n  }, [t, n]), r;\n}\n\nfunction r(_ref, r) {\n  let [t, n] = _ref;\n  let u,\n      a,\n      s,\n      l = j;\n  n ? (u = n, a = t, s = []) : (u = t.fn, a = t.store, s = t.keys, l = t.updateFilter || j), v.store(a) || S('useStoreMap expects a store'), Array.isArray(s) || S('useStoreMap expects an array as keys'), 'function' != typeof u && S('useStoreMap expects a function');\n  let c = m.useRef({}),\n      i = c.current;\n  i.fn = u, i.upd = l, i.init = i.store === a, i.store = a, i.active = 1, b(() => () => {\n    c.current && (c.current.active = 0);\n  }, []);\n  let f = N(),\n      p = [r, ...s],\n      d = m.useMemo(() => (o(w(a, r), s, c.current), e(a, e => o(e, s, c.current, f), r)), p);\n  return b(() => () => d(), p), i.val;\n}\n\nfunction o(e, t, n, r) {\n  let o = n.fn(e, t);\n  n.init ? void 0 !== o && j(o, n.val) && n.upd(o, n.val) && (n.val = o, r && n.active && r()) : (n.val = o, n.init = 1);\n}\n\nfunction u(e) {\n  return e;\n}\n\nfunction a(e) {\n  return n(e);\n}\n\nfunction s(e, t) {\n  return r([e, t]);\n}\n\nfunction l(e, o) {\n  return ((e, o, u) => {\n    let a,\n        s,\n        l = [];\n    'object' == typeof o && null !== o ? (o.keys && (l = o.keys), a = o.fn, o.getKey && (s = o.getKey)) : a = o, v.store(e) || S('expect useList first argument to be a store'), 'function' != typeof a && S(\"expect useList's renderItem to be a function\"), Array.isArray(l) || S(\"expect useList's keys to be an array\");\n    let c = m.useMemo(() => {\n      let n = t(`${e.shortName || 'Unknown'}.Item`, t => {\n        let {\n          index: n,\n          keys: o,\n          keyVal: a,\n          value: s\n        } = t;\n        if (i.current[1]) return i.current[0](s, a);\n        let l = r([{\n          store: e,\n          keys: [n, ...o],\n          fn: (e, t) => e[t[0]]\n        }], u);\n        return i.current[0](l, n);\n      });\n      return m.memo(n);\n    }, [e, u, !!s]),\n        i = m.useRef([a, s]);\n    i.current = [a, s];\n    let f = m.useMemo(() => l, l);\n    if (s) return n(e, u).map(e => {\n      let t = i.current[1](e);\n      return m.createElement(c, {\n        keyVal: t,\n        key: t,\n        keys: f,\n        value: e\n      });\n    });\n    {\n      let t = r([{\n        store: e,\n        keys: [e],\n        fn: e => e.length\n      }], u);\n      return Array.from({\n        length: t\n      }, (e, t) => m.createElement(c, {\n        index: t,\n        key: t,\n        keys: f\n      }));\n    }\n  })(e, o);\n}\n\nfunction c(e, n) {\n  function r(e) {\n    let t = m.useRef(e),\n        r = a(o);\n    b(() => (s({\n      props: t.current,\n      state: o.getState()\n    }), () => {\n      l({\n        props: t.current,\n        state: o.getState()\n      });\n    }), []);\n    let u = n(e, r);\n    return t.current = e, u;\n  }\n\n  let o;\n  v.store(e) ? o = e : 'object' == typeof e && null !== e ? o = g(e) : S('shape should be a store or object with stores');\n  let u = 'Unknown';\n  o && o.shortName && (u = o.shortName);\n  let s = h(),\n      l = h();\n  return r.mounted = s, r.unmounted = l, t(`${u}.View`, r);\n}\n\nfunction i(e) {\n  return c(e, (_ref2, t) => {\n    let {\n      children: e\n    } = _ref2;\n    return e(t);\n  });\n}\n\nfunction f(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let n = m.useRef({\n    value: null,\n    count: 0\n  });\n  b(() => (e.open(n.current.value), () => e.close(n.current.value)), [e]), ((e, t) => {\n    if (e === t) return 1;\n\n    if ('object' == typeof e && null !== e && 'object' == typeof t && null !== t) {\n      let n = Object.keys(e),\n          r = Object.keys(t);\n      if (n.length !== r.length) return 0;\n\n      for (let r = 0; r < n.length; r++) {\n        let o = n[r];\n        if (e[o] !== t[o]) return 0;\n      }\n\n      return 1;\n    }\n\n    return 0;\n  })(n.current.value, t) || (n.current.value = t, n.current.count += 1), b(() => {\n    e.set(n.current.value);\n  }, [n.current.count]);\n}\n\nfunction p() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"gate\";\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let r;\n  return 'object' == typeof e && null !== e && ('defaultState' in e && (n = e.defaultState), e.domain && (r = e.domain), e = e.name), (_ref3 => {\n    let {\n      name: e = \"gate\",\n      domain: n,\n      defaultState: r,\n      hook: o\n    } = _ref3;\n\n    function u(e) {\n      return o(u, e), null;\n    }\n\n    let a = `${n ? `${n.compositeName.fullName}/` : ''}${e}`,\n        s = h(`${a}.set`),\n        l = h(`${a}.open`),\n        c = h(`${a}.close`),\n        i = x(Boolean(0), {\n      name: `${a}.status`\n    }).on(l, () => Boolean(1)).on(c, () => Boolean(0)),\n        f = x(r, {\n      name: `${a}.state`\n    }).on(s, (e, t) => t).reset(c);\n\n    if (n) {\n      let {\n        hooks: e\n      } = n;\n      $({\n        target: [e.store, e.store, e.event, e.event, e.event],\n        params: [i, f, l, c, s]\n      });\n    }\n\n    return u.open = l, u.close = c, u.status = i, u.state = f, u.set = s, t(`Gate:${a}`, u);\n  })({\n    name: e,\n    domain: r,\n    defaultState: n,\n    hook: f\n  });\n}\n\nimport m from 'react';\nimport { step as d, createNode as y, clearNode as k, is as v, combine as g, createEvent as h, createStore as x, launch as $ } from 'effector/effector.mjs';\n\nlet b = 'undefined' != typeof window ? m.useLayoutEffect : m.useEffect,\n    S = e => {\n  throw Error(e);\n};\n\nconst w = (e, t) => t ? t.getState(e) : e.getState(),\n      j = (e, t) => e !== t,\n      N = () => m.useReducer(e => e + 1, 0)[1];\n\nlet R = e => console.error(`${e} is deprecated`),\n    C = (e, n, r) => (R('createContextComponent'), t(`${e.shortName || 'Unknown'}.ContextComponent`, t => {\n  let o = m.useContext(n),\n      u = a(e);\n  return r(t, u, o);\n})),\n    E = e => n => {\n  let r = e;\n  return 'function' != typeof e && (r = n, n = e), t(`Connect(${r.displayName || r.name || 'Unknown'})`, e => m.createElement(r, { ...e,\n    ...a(n)\n  }));\n},\n    M = (e, t) => (R('createReactState'), E(t)(e));\n\nexport { E as connect, c as createComponent, C as createContextComponent, p as createGate, M as createReactState, i as createStoreConsumer, u as useEvent, f as useGate, l as useList, a as useStore, s as useStoreMap };","map":{"version":3,"mappings":"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","names":["createWatch","store","fn","scope","seq","step","run","value","node","createNode","id","graphite","scopeLinks","additionalLinks","links","push","idx","indexOf","splice","clearNode","parent","family","owners","withDisplayName","name","Component","displayName","useStoreBase","is","throwError","currentValue","stateReader","inc","createNotifier","currentStore","React","useRef","pending","useIsomorphicLayoutEffect","stop","upd","ref","current","newValue","useStoreMapBase","configOrStore","separateFn","keys","updateFilter","basicUpdateFilter","Array","isArray","result","refState","init","active","deps","useMemo","updateRef","val","sourceValue","undefined","useEvent","event","useStore","useStoreMap","useList","list","renderItem","getKey","Item","shortName","props","index","keyVal","fnRef","item","memo","keysSelfMemo","map","key","createElement","length","from","_","i","createComponent","shape","renderProp","RenderComponent","propsRef","state","mounted","getState","unmounted","combine","storeName","createEvent","createStoreConsumer","children","useGate","GateComponent","count","open","close","a","b","aKeys","Object","bKeys","set","createGate","defaultState","domain","useGateHook","hook","fullName","compositeName","status","createStore","Boolean","on","reset","hooks","launch","target","params","window","useLayoutEffect","useEffect","message","Error","oldValue","useReducer","n","deprecate","method","console","error","createContextComponent","context","ctx","useContext","connect","View","createReactState"],"sources":["/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createWatch.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/withDisplayName.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/apiBase.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/nossr.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createComponent.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createStoreConsumer.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createGate.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/throw.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/deprecate.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createContextComponent.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/connect.ts","/Users/s.shakirova/Desktop/GitHub/device/node_modules/effector-react/effector-react/createReactState.ts"],"sourcesContent":["import {Store, clearNode, step, createNode, Scope, Node} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n) {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, Scope} from 'effector'\nimport React from 'react'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst createNotifier = () =>\n  React.useReducer((n: any, action: void) => n + 1, 0)[1]\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const currentValue = stateReader(store, scope)\n  const inc = createNotifier()\n  const currentStore = React.useRef({\n    store,\n    value: currentValue,\n    pending: false,\n  })\n  useIsomorphicLayoutEffect(() => {\n    const stop = createWatch(\n      store,\n      upd => {\n        const ref = currentStore.current\n        if (!ref.pending) {\n          ref.value = upd\n          ref.pending = true\n          inc()\n          ref.pending = false\n        }\n      },\n      scope,\n    )\n    const newValue = stateReader(store, scope)\n    const ref = currentStore.current\n    if (ref.store === store && ref.value !== newValue) {\n      ref.value = newValue\n      ref.pending = true\n      inc()\n      ref.pending = false\n    }\n    ref.store = store\n    return stop\n  }, [store, scope])\n  return currentValue\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    fn = (configOrStore as any).fn\n    store = (configOrStore as any).store\n    keys = (configOrStore as any).keys\n    updateFilter = (configOrStore as any).updateFilter || basicUpdateFilter\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n  const result = React.useRef<{\n    fn: (state: State, keys: Keys) => Result\n    upd: (update: Result, current: Result) => boolean\n    val: Result\n    init: boolean\n    store: Store<State>\n    active: boolean\n  }>({} as any)\n  const refState = result.current\n  refState.fn = fn\n  refState.upd = updateFilter\n  refState.init = refState.store === store\n  refState.store = store\n  refState.active = true\n  useIsomorphicLayoutEffect(\n    () => () => {\n      if (result.current) {\n        result.current.active = false\n      }\n    },\n    [],\n  )\n  const inc = createNotifier()\n  const deps = [scope, ...keys]\n  const stop = React.useMemo(() => {\n    updateRef(stateReader(store, scope), keys, result.current)\n    return createWatch(\n      store,\n      val => updateRef(val, keys, result.current, inc),\n      scope,\n    )\n  }, deps)\n  useIsomorphicLayoutEffect(() => () => stop(), deps)\n  return refState.val\n}\nfunction updateRef<State, Keys, Result>(\n  sourceValue: State,\n  keys: Keys,\n  refState: {\n    fn: (state: State, keys: Keys) => Result\n    upd: (update: Result, current: Result) => boolean\n    val: Result\n    init: boolean\n    active: boolean\n  },\n  inc?: React.DispatchWithoutAction,\n) {\n  const newValue = refState.fn(sourceValue, keys)\n  if (!refState.init) {\n    refState.val = newValue\n    refState.init = true\n  } else {\n    if (\n      newValue !== undefined &&\n      basicUpdateFilter(newValue, refState.val) &&\n      refState.upd(newValue, refState.val)\n    ) {\n      refState.val = newValue\n      inc && refState.active && inc()\n    }\n  }\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: (item: T) => string\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    fn = renderItem.fn\n    if (renderItem.getKey) getKey = renderItem.getKey\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    return useStoreBase(list, scope).map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n","import {Event, Store} from 'effector'\nimport {useStoreBase, useStoreMapBase, useListBase} from './apiBase'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(event: Event<T>): (payload: T) => T {\n  return event\n}\n\nexport function useStore<State>(store: Store<State>): State {\n  return useStoreBase(store)\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase([configOrStore, separateFn])\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n      }\n    | ((item: T, index: number) => React.ReactNode),\n): React.ReactNode {\n  return useListBase(list, renderItem)\n}\n","import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n","import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n","import React from 'react'\nimport {createStore, launch, Store, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {withDisplayName} from './withDisplayName'\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n) {\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.open(propsRef.current.value)\n    return () => GateComponent.close(propsRef.current.value) as any\n  }, [GateComponent])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\nexport function createGateImplementation<State>({\n  name = 'gate',\n  domain,\n  defaultState,\n  hook: useGateHook,\n}: {\n  name?: string\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGate\n}): Gate<State> {\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>(`${fullName}.set`)\n  const open = createEvent<State>(`${fullName}.open`)\n  const close = createEvent<State>(`${fullName}.close`)\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n  })\n    .on(set, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props)\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\nexport function createGate<Props>(\n  name: string = 'gate',\n  defaultState: Props = {} as any,\n): Gate<Props> {\n  let domain\n  if (typeof name === 'object' && name !== null) {\n    if ('defaultState' in name) {\n      //@ts-ignore\n      defaultState = name.defaultState\n    }\n    //@ts-ignore\n    if (name.domain) domain = name.domain\n    //@ts-ignore\n    name = name.name\n  }\n  return createGateImplementation({\n    name,\n    domain,\n    defaultState,\n    hook: useGate,\n  })\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","export const deprecate = (method: string) =>\n  console.error(`${method} is deprecated`)\n","import React from 'react'\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> => {\n  deprecate('createContextComponent')\n  return withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n}\n","import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\n\nexport const connect =\n  <State>(Component: React.ComponentType<any>) =>\n  (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n","import type {ComponentType} from 'react'\nimport type {Store} from 'effector'\n\nimport {connect} from './connect'\nimport {deprecate} from './deprecate'\n\nexport const createReactState = (\n  store: Store<any>,\n  View: ComponentType<any>,\n) => {\n  deprecate('createReactState')\n  return connect(View)(store)\n}\n"]},"metadata":{},"sourceType":"module"}