{"ast":null,"code":"function e(e, t) {\n  for (let r in e) t(e[r], r);\n}\n\nfunction t(e, t) {\n  e.forEach(t);\n}\n\nfunction r(e, t) {\n  if (!e) throw Error(t);\n}\n\nfunction n(e, t) {\n  ue = {\n    parent: ue,\n    value: e,\n    template: ne(e, 'template') || ce(),\n    sidRoot: ne(e, 'sidRoot') || ue && ue.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    ue = te(ue);\n  }\n}\n\nfunction a() {\n  let {\n    node: e = [],\n    from: r,\n    source: n,\n    parent: a = r || n,\n    to: o,\n    target: l,\n    child: i = o || l,\n    scope: s = {},\n    meta: f = {},\n    family: u = {\n      type: 'regular'\n    },\n    regional: c\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let d = ge(a),\n      p = ge(u.links),\n      m = ge(u.owners),\n      g = [];\n  t(e, e => e && G(g, e));\n  let h = {\n    id: fe(),\n    seq: g,\n    next: ge(i),\n    meta: f,\n    scope: s,\n    family: {\n      type: u.type || \"crosslink\",\n      links: p,\n      owners: m\n    }\n  };\n  return t(p, e => G(Q(e), h)), t(m, e => G(X(e), h)), t(d, e => G(e.next, h)), c && ue && me(Z(ue), [h]), h;\n}\n\nfunction o(e, r, n) {\n  let a = Xe,\n      o = null,\n      l = Ge;\n  if (e.target && (r = e.params, n = e.defer, a = 'page' in e ? e.page : a, e.stack && (o = e.stack), l = re(e) || l, e = e.target), l && Ge && l !== Ge && (Ge = null), Array.isArray(e)) for (let t = 0; t < e.length; t++) Te('pure', a, K(e[t]), o, r[t], l);else Te('pure', a, K(e), o, r, l);\n  if (n && !Je) return;\n  let i,\n      s,\n      f,\n      u,\n      c,\n      d,\n      p = {\n    isRoot: Je,\n    currentPage: Xe,\n    scope: Ge,\n    isWatch: Ke,\n    isPure: Qe\n  };\n  Je = 0;\n\n  e: for (; u = Le();) {\n    let {\n      idx: e,\n      stack: r,\n      type: n\n    } = u;\n    f = r.node, Xe = c = r.page, Ge = re(r), c ? d = c.reg : Ge && (d = Ge.reg);\n    let a = !!c,\n        o = !!Ge,\n        l = {\n      fail: 0,\n      scope: f.scope\n    };\n    i = s = 0;\n\n    for (let t = e; t < f.seq.length && !i; t++) {\n      let u = f.seq[t];\n\n      if (u.order) {\n        let {\n          priority: a,\n          barrierID: o\n        } = u.order,\n            l = o ? c ? `${c.fullID}_${o}` : o : 0;\n\n        if (t !== e || n !== a) {\n          o ? Ue.has(l) || (Ue.add(l), We(t, r, a, o)) : We(t, r, a);\n          continue e;\n        }\n\n        o && Ue.delete(l);\n      }\n\n      switch (u.type) {\n        case 'mov':\n          {\n            let e,\n                t = u.data;\n\n            switch (t.from) {\n              case z:\n                e = Z(r);\n                break;\n\n              case \"a\":\n              case 'b':\n                e = r[t.from];\n                break;\n\n              case \"value\":\n                e = t.store;\n                break;\n\n              case \"store\":\n                if (d && !d[t.store.id]) if (a) {\n                  let e = et(c, t.store.id);\n                  r.page = c = e, e ? d = e.reg : o ? (rt(Ge, t.store, 0, 1, t.softRead), d = Ge.reg) : d = void 0;\n                } else o && rt(Ge, t.store, 0, 1, t.softRead);\n                e = ze(d && d[t.store.id] || t.store);\n            }\n\n            switch (t.to) {\n              case z:\n                r.value = e;\n                break;\n\n              case \"a\":\n              case 'b':\n                r[t.to] = e;\n                break;\n\n              case \"store\":\n                tt(c, Ge, f, t.target).current = e;\n            }\n\n            break;\n          }\n\n        case 'compute':\n          let e = u.data;\n\n          if (e.fn) {\n            Ke = 'watch' === ne(f, 'op'), Qe = e.pure;\n            let t = e.safe ? (0, e.fn)(Z(r), l.scope, r) : nt(l, e.fn, r);\n            e.filter ? s = !t : r.value = t, Ke = p.isWatch, Qe = p.isPure;\n          }\n\n      }\n\n      i = l.fail || s;\n    }\n\n    if (!i) {\n      let e = Z(r);\n      t(f.next, t => {\n        Te('child', c, t, r, e, re(r));\n      });\n      let n = re(r);\n\n      if (n) {\n        ne(f, 'needFxCounter') && Te('child', c, n.fxCount, r, e, n), ne(f, 'storeChange') && Te('child', c, n.storeChange, r, e, n);\n        let a = n.additionalLinks[f.id];\n        a && t(a, t => {\n          Te('child', c, t, r, e, n);\n        });\n      }\n    }\n  }\n\n  Je = p.isRoot, Xe = p.currentPage, Ge = re(p);\n}\n\nfunction l(t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  let n = r + '(',\n      a = '',\n      o = 0;\n  return e(t, e => {\n    o < 25 && (null != e && (n += a, n += _(e) ? oe(e).fullName : e.toString()), o += 1, a = ', ');\n  }), n + ')';\n}\n\nfunction i(e, t) {\n  e.shortName = t, Object.assign(oe(e), s(t, te(e)));\n}\n\nfunction s(e, t) {\n  let r,\n      n,\n      a = e;\n\n  if (t) {\n    let a = oe(t);\n    0 === e.length ? (r = a.path, n = a.fullName) : (r = a.path.concat([e]), n = 0 === a.fullName.length ? e : a.fullName + '/' + e);\n  } else r = 0 === e.length ? [] : [e], n = e;\n\n  return {\n    shortName: a,\n    fullName: n,\n    path: r\n  };\n}\n\nfunction f(e, t) {\n  let r = t ? e : e[0];\n  ve(r);\n  let n = r.or,\n      a = r.and;\n\n  if (a) {\n    let r = t ? a : a[0];\n\n    if (he(r) && 'and' in r) {\n      let r = f(a, t);\n      e = r[0], n = { ...n,\n        ...r[1]\n      };\n    } else e = a;\n  }\n\n  return [e, n];\n}\n\nfunction u(e) {\n  let r = ce();\n\n  if (r) {\n    let n = r.handlers[e];\n\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n\n    if (n) return n(r, ...t);\n  }\n}\n\nfunction c(e, t) {\n  let r = function (e) {\n    for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      t[_key2 - 1] = arguments[_key2];\n    }\n\n    return J(!ne(r, 'derived'), 'call of derived event', 'createEvent'), J(!Qe, 'unit call from pure function', 'operators like sample'), Xe ? ((e, t, r, n) => {\n      let a = Xe,\n          o = null;\n      if (t) for (o = Xe; o && o.template !== t;) o = te(o);\n      Ze(o);\n      let l = e.create(r, n);\n      return Ze(a), l;\n    })(r, n, e, t) : r.create(e, t);\n  },\n      n = ce();\n\n  return Object.assign(r, {\n    graphite: a({\n      meta: gt(\"event\", r, e, t),\n      regional: 1\n    }),\n    create: e => (o({\n      target: r,\n      params: e,\n      scope: Ge\n    }), e),\n    watch: e => pt(r, e),\n    map: e => yt(r, R, e, [Fe()]),\n    filter: e => yt(r, \"filter\", e.fn ? e : e.fn, [Fe(Ce, 1)]),\n    filterMap: e => yt(r, 'filterMap', e, [Fe(), Ne(e => !be(e), 1)]),\n\n    prepend(e) {\n      let t = c('* \\u2192 ' + r.shortName, {\n        parent: te(r)\n      });\n      return u('eventPrepend', K(t)), ct(t, r, [Fe()], 'prepend', e), mt(r, t), t;\n    }\n\n  });\n}\n\nfunction d(e, n) {\n  let l = Re(e),\n      i = ht('updates');\n  u('storeBase', l);\n  let s = l.id,\n      f = {\n    subscribers: new Map(),\n    updates: i,\n    defaultState: e,\n    stateRef: l,\n\n    getState() {\n      let e,\n          t = l;\n\n      if (Xe) {\n        let t = Xe;\n\n        for (; t && !t.reg[s];) t = te(t);\n\n        t && (e = t);\n      }\n\n      return !e && Ge && (rt(Ge, l, 1), e = Ge), e && (t = e.reg[s]), ze(t);\n    },\n\n    setState: e => o({\n      target: f,\n      params: e,\n      defer: 1,\n      scope: Ge\n    }),\n    reset: function () {\n      for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        e[_key3] = arguments[_key3];\n      }\n\n      return t(e, e => f.on(e, () => f.defaultState)), f;\n    },\n    on: (e, r) => (we(e, '.on', 'first argument'), J(!ne(f, 'derived'), '.on in derived store', 'createStore'), t(Array.isArray(e) ? e : [e], e => {\n      f.off(e), ee(f).set(e, ut(bt(e, f, 'on', $e, r)));\n    }), f),\n\n    off(e) {\n      let t = ee(f).get(e);\n      return t && (t(), ee(f).delete(e)), f;\n    },\n\n    map(e, t) {\n      let r, n;\n      he(e) && (r = e, e = e.fn), J(be(t), 'second argument of store.map', 'updateFilter');\n      let a = f.getState();\n      ce() ? n = null : be(a) || (n = e(a, t));\n      let o = d(n, {\n        name: `${f.shortName} \\u2192 *`,\n        derived: 1,\n        and: r\n      }),\n          i = bt(f, o, R, Se, e);\n      return _e(Y(o), {\n        type: R,\n        fn: e,\n        from: l\n      }), Y(o).noInit = 1, u('storeMap', l, i), o;\n    },\n\n    watch(e, t) {\n      if (!t || !_(e)) {\n        let t = pt(f, e);\n        return u('storeWatch', l, e) || e(f.getState()), t;\n      }\n\n      return r(ye(t), 'second argument should be a function'), e.watch(e => t(f.getState(), e));\n    }\n\n  },\n      c = gt(\"store\", f, n),\n      p = f.defaultConfig.updateFilter;\n  f.graphite = a({\n    scope: {\n      state: l,\n      fn: p\n    },\n    node: [Ne((e, t, r) => (r.scope && !r.scope.reg[l.id] && (r.b = 1), e)), Oe(l), Ne((e, t, _ref) => {\n      let {\n        a: r,\n        b: n\n      } = _ref;\n      return !be(e) && (e !== r || n);\n    }, 1), p && Fe(Se, 1), Ae({\n      from: z,\n      target: l\n    })],\n    child: i,\n    meta: c,\n    regional: 1\n  });\n  let m = ne(f, 'sid');\n  return m && ('ignore' !== ne(f, 'serialize') && ae(f, 'storeChange', 1), l.sid = m), r(ne(f, 'derived') || !be(e), \"current state can't be undefined, use null instead\"), me(f, [i]), f;\n}\n\nfunction p() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n\n  let t, n, a;\n  [e, a] = f(e);\n  let o,\n      l,\n      i,\n      s = e[e.length - 1];\n\n  if (ye(s) ? (n = e.slice(0, -1), t = s) : n = e, 1 === n.length) {\n    let e = n[0];\n    V(e) || (o = e, l = 1);\n  }\n\n  if (!l && (o = n, t)) {\n    i = 1;\n    let e = t;\n\n    t = t => e(...t);\n  }\n\n  return r(he(o), 'shape should be an object'), vt(Array.isArray(o), !i, o, a, t);\n}\n\nfunction m() {\n  return J(0, 'createStoreObject', 'combine'), p(...arguments);\n}\n\nfunction g() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\n\nfunction h(e, t) {\n  let n = c(ye(e) ? {\n    handler: e\n  } : e, t),\n      l = K(n);\n  ae(l, 'op', n.kind = \"effect\"), n.use = e => (r(ye(e), '.use argument should be a function'), m.scope.handler = e, n), n.use.getCurrent = () => m.scope.handler;\n  let i = n.finally = ht('finally'),\n      s = n.done = i.filterMap({\n    named: 'done',\n\n    fn(_ref2) {\n      let {\n        status: e,\n        params: t,\n        result: r\n      } = _ref2;\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n\n  }),\n      f = n.fail = i.filterMap({\n    named: 'fail',\n\n    fn(_ref3) {\n      let {\n        status: e,\n        params: t,\n        error: r\n      } = _ref3;\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n\n  }),\n      u = n.doneData = s.map({\n    named: 'doneData',\n    fn: _ref4 => {\n      let {\n        result: e\n      } = _ref4;\n      return e;\n    }\n  }),\n      p = n.failData = f.map({\n    named: 'failData',\n    fn: _ref5 => {\n      let {\n        error: e\n      } = _ref5;\n      return e;\n    }\n  }),\n      m = a({\n    scope: {\n      handlerId: ne(l, 'sid'),\n      handler: n.defaultConfig.handler || (() => r(0, `no handler used in ${n.getType()}`))\n    },\n    node: [Ne((e, t, r) => {\n      let n = t,\n          a = n.handler;\n\n      if (re(r)) {\n        let e = re(r).handlers[n.handlerId];\n        e && (a = e);\n      }\n\n      return e.handler = a, e;\n    }, 0, 1), Ne((_ref6, a, o) => {\n      let {\n        params: e,\n        req: t,\n        handler: r,\n        args: n = [e]\n      } = _ref6;\n      let l = wt(e, t, 1, i, o),\n          s = wt(e, t, 0, i, o),\n          [f, u] = kt(r, s, n);\n      f && (he(u) && ye(u.then) ? u.then(l, s) : l(u));\n    }, 0, 1)],\n    meta: {\n      op: 'fx',\n      fx: 'runner'\n    }\n  });\n  l.scope.runner = m, G(l.seq, Ne((e, _ref7, r) => {\n    let {\n      runner: t\n    } = _ref7;\n    let n = te(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n\n        rj(e) {}\n\n      }\n    } : e;\n    return o({\n      target: t,\n      params: n,\n      defer: 1,\n      scope: re(r)\n    }), n.params;\n  }, 0, 1)), n.create = e => {\n    let t = g(),\n        r = {\n      params: e,\n      req: t\n    };\n\n    if (Ge) {\n      if (!Ke) {\n        let e = Ge;\n        t.req.finally(() => {\n          Ye(e);\n        }).catch(() => {});\n      }\n\n      o({\n        target: n,\n        params: r,\n        scope: Ge\n      });\n    } else o(n, r);\n\n    return t.req;\n  };\n  let h = n.inFlight = d(0, {\n    named: 'inFlight'\n  }).on(n, e => e + 1).on(i, e => e - 1);\n  ae(i, 'needFxCounter', 'dec'), ae(n, 'needFxCounter', 1);\n  let y = n.pending = h.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return me(n, [i, s, f, u, p, y, h]), n;\n}\n\nfunction y(e) {\n  let t;\n  [e, t] = f(e, 1);\n  let {\n    source: r,\n    effect: n,\n    mapParams: a\n  } = e,\n      l = h(e, t);\n  ae(l, 'attached', 1);\n  let i,\n      {\n    runner: u\n  } = K(l).scope,\n      c = Ne((e, t, n) => {\n    let i,\n        {\n      params: s,\n      req: f,\n      handler: u\n    } = e,\n        c = l.finally,\n        d = wt(s, f, 0, c, n),\n        p = n.a,\n        m = B(u),\n        g = 1;\n\n    if (a ? [g, i] = kt(a, d, [s, p]) : i = r && m ? p : s, g) {\n      if (!m) return e.args = [p, i], 1;\n      o({\n        target: u,\n        params: {\n          params: i,\n          req: {\n            rs: wt(s, f, 1, c, n),\n            rj: d\n          }\n        },\n        page: n.page,\n        defer: 1\n      });\n    }\n  }, 1, 1);\n\n  if (r) {\n    let e;\n    V(r) ? (e = r, me(e, [l])) : (e = p(r), me(l, [e])), i = [Oe(Y(e)), c];\n  } else i = [c];\n\n  u.seq.splice(1, 0, ...i), l.use(n);\n  let d = te(n);\n  return d && (Object.assign(oe(l), s(l.shortName, d)), l.defaultConfig.parent = d), mt(n, l, \"effect\"), l;\n}\n\nfunction b() {\n  for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    t[_key5] = arguments[_key5];\n  }\n\n  let [[r, n], a] = f(t),\n      o = {};\n  return e(n, (e, t) => {\n    let n = o[t] = c(t, {\n      parent: te(r),\n      config: a\n    });\n    r.on(n, e), mt(r, n);\n  }), o;\n}\n\nfunction v(r, n) {\n  let l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      i = {\n    history: {},\n    graphite: l,\n    hooks: {}\n  };\n  l.meta = gt(\"domain\", i, r, n), e({\n    Event: c,\n    Effect: h,\n    Store: d,\n    Domain: v\n  }, (e, r) => {\n    let n = r.toLowerCase(),\n        a = ht(`on${r}`);\n    i.hooks[n] = a;\n    let l = new Set();\n    i.history[`${n}s`] = l, a.create = e => (o(a, e), e), G(K(a).seq, Ne((e, t, r) => (r.scope = null, e))), a.watch(e => {\n      me(i, [e]), l.add(e), e.ownerSet || (e.ownerSet = l), te(e) || (e.parent = i);\n    }), me(i, [a]), i[`onCreate${r}`] = e => (t(l, e), a.watch(e)), i[`create${r}`] = i[n] = (t, r) => a(e(t, {\n      parent: i,\n      or: r\n    }));\n  });\n  let s = te(i);\n  return s && e(i.hooks, (e, t) => ct(e, s.hooks[t])), i;\n}\n\nfunction k(e) {\n  ve(e);\n  let t = D in e ? e[D]() : e;\n  r(t.subscribe, 'expect observable to have .subscribe');\n  let n = c(),\n      a = ut(n);\n  return t.subscribe({\n    next: n,\n    error: a,\n    complete: a\n  }), n;\n}\n\nfunction w(e, t) {\n  we(e, 'merge', 'first argument');\n  let r = c({\n    name: l(e, 'merge'),\n    derived: 1,\n    and: t\n  });\n  return ct(e, r, [], 'merge'), r;\n}\n\nfunction x(e, n) {\n  let a = 0;\n  return t(St, t => {\n    t in e && (r(null != e[t], $t(n, t)), a = 1);\n  }), a;\n}\n\nfunction S() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n\n  let t,\n      r,\n      n,\n      a,\n      [[o, l, i], s] = f(e),\n      u = 1;\n  return be(l) && he(o) && x(o, \"sample\") && (l = o.clock, i = o.fn, u = !o.greedy, a = o.filter, t = o.target, r = o.name, n = o.sid, o = o.source), Ct(\"sample\", l, o, a, t, i, r, s, u, 1, 0, n);\n}\n\nfunction $() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n\n  let [[t, r], n] = f(e);\n  return r || (r = t, t = r.source), x(r, 'guard'), Ct('guard', r.clock, t, r.filter, r.target, null, r.name, n, !r.greedy, 0, 1);\n}\n\nfunction C(t, r, n) {\n  if (V(t)) return J(0, 'restore($store)'), t;\n\n  if (E(t) || B(t)) {\n    let e = te(t),\n        a = d(r, {\n      parent: e,\n      name: t.shortName,\n      and: n\n    });\n    return ct(B(t) ? t.doneData : t, a), e && e.hooks.store(a), a;\n  }\n\n  let a = Array.isArray(t) ? [] : {};\n  return e(t, (e, t) => a[t] = V(e) ? e : d(e, {\n    name: t\n  })), a;\n}\n\nfunction M() {\n  for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    t[_key8] = arguments[_key8];\n  }\n\n  let n,\n      o,\n      l = 'split',\n      [[i, s], d] = f(t),\n      p = !s;\n  p && (n = i.cases, s = i.match, o = i.clock, i = i.source);\n  let m = V(s),\n      g = !_(s) && ye(s),\n      h = !m && !g && he(s);\n  n || (n = {}), p ? e(n, (e, t) => xe(l, e, `cases.${t}`)) : (r(h, 'match should be an object'), e(s, (e, t) => n[t] = c({\n    derived: 1,\n    and: d\n  })), n.__ = c({\n    derived: 1,\n    and: d\n  }));\n  let y,\n      b = new Set([].concat(i, o || [], Object.values(n))),\n      v = Object.keys(m || g ? n : s);\n  if (m || g) m && b.add(s), y = [m && Oe(Y(s), 0, 1), Ie({\n    safe: m,\n    filter: 1,\n    pure: !m,\n\n    fn(e, t, r) {\n      let n = String(m ? r.a : s(e));\n      At(t, H(v, n) ? n : '__', e, r);\n    }\n\n  })];else if (h) {\n    let t = Re({});\n    t.type = 'shape';\n    let r,\n        n = [];\n    e(s, (e, a) => {\n      if (_(e)) {\n        r = 1, G(n, a), b.add(e);\n        let o = ct(e, [], [Oe(t), Ne((e, t, _ref8) => {\n          let {\n            a: r\n          } = _ref8;\n          return r[a] = e;\n        })]);\n\n        if (V(e)) {\n          t.current[a] = e.getState();\n          let r = Y(e);\n          _e(t, {\n            from: r,\n            field: a,\n            type: 'field'\n          }), u('splitMatchStore', r, o);\n        }\n      }\n    }), r && u('splitBase', t), y = [r && Oe(t, 0, 1), Fe((e, t, r) => {\n      for (let a = 0; a < v.length; a++) {\n        let o = v[a];\n        if (H(n, o) ? r.a[o] : s[o](e)) return void At(t, o, e, r);\n      }\n\n      At(t, '__', e, r);\n    }, 1)];\n  } else r(0, 'expect match to be unit, function or object');\n  let k = a({\n    meta: {\n      op: l\n    },\n    parent: o ? [] : i,\n    scope: n,\n    node: y,\n    family: {\n      owners: Array.from(b)\n    },\n    regional: 1\n  });\n  if (o && Ct(l, o, i, null, k, null, l, d, 0, 0, 0), !p) return n;\n}\n\nfunction j(e, _ref9) {\n  let {\n    scope: t,\n    params: r\n  } = _ref9;\n  if (!_(e)) return Promise.reject(Error('first argument should be unit'));\n  let n = g();\n  n.parentFork = Ge;\n  let {\n    fxCount: a\n  } = t;\n  G(a.scope.defers, n);\n  let l = [e],\n      i = [];\n  return G(i, B(e) ? {\n    params: r,\n    req: {\n      rs(e) {\n        n.value = {\n          status: 'done',\n          value: e\n        };\n      },\n\n      rj(e) {\n        n.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n\n    }\n  } : r), G(l, a), G(i, null), o({\n    target: l,\n    params: i,\n    scope: t\n  }), n.req;\n}\n\nfunction A(e, r) {\n  let n = [];\n\n  (function e(a) {\n    H(n, a) || (G(n, a), \"store\" === ne(a, 'op') && ne(a, 'sid') && r(a, ne(a, 'sid')), t(a.next, e), t(Q(a), e), t(X(a), e));\n  })(e);\n}\n\nfunction I(e, n) {\n  if (Array.isArray(e) && (e = new Map(e)), e instanceof Map) {\n    let a = {};\n    return t(e, (e, t) => {\n      r(_(t), 'Map key should be a unit'), n && n(t, e), r(t.sid, 'unit should have a sid'), r(!(t.sid in a), 'duplicate sid found'), a[t.sid] = e;\n    }), a;\n  }\n\n  return e;\n}\n\nfunction q(e, n) {\n  let o,\n      l = e;\n  L(e) && (o = e, l = n);\n\n  let i = (e => {\n    let r = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [Ne((e, t, r) => {\n        te(r) ? 'dec' === ne(te(r).node, 'needFxCounter') ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n      }), Ie({\n        priority: \"sampler\",\n        batch: 1\n      }), Ne((e, r) => {\n        let {\n          defers: n,\n          fxID: a\n        } = r;\n        r.inFlight > 0 || 0 === n.length || Promise.resolve().then(() => {\n          r.fxID === a && t(n.splice(0, n.length), e => {\n            Ye(e.parentFork), e.rs(e.value);\n          });\n        });\n      }, 0, 1)]\n    }),\n        n = a({\n      node: [Ne((e, t, r) => {\n        let n = te(r);\n\n        if (n && te(n)) {\n          let t = n.node;\n\n          if (!ne(t, 'isCombine') || 'combine' !== ne(te(n).node, 'op')) {\n            let n = re(r),\n                a = t.scope.state.id,\n                o = ne(t, 'sid');\n            n.sidIdMap[o] = a, n.sidValuesMap[o] = e;\n          }\n        }\n      })]\n    }),\n        o = {\n      cloneOf: e,\n      reg: {},\n      sidValuesMap: {},\n      sidIdMap: {},\n\n      getState(e) {\n        if ('current' in e) return tt(Xe, o, null, e).current;\n        let t = K(e);\n        return tt(Xe, o, t, t.scope.state, 1).current;\n      },\n\n      kind: \"scope\",\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [r, n]\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: r\n        }\n      }),\n      additionalLinks: {},\n      handlers: {},\n      fxCount: r,\n      storeChange: n\n    };\n    return o;\n  })(o);\n\n  if (l) {\n    if (l.values) {\n      let e = I(l.values, e => r(V(e), 'Values map can contain only stores as keys'));\n      Object.assign(i.sidValuesMap, e);\n    }\n\n    l.handlers && (i.handlers = I(l.handlers, e => r(B(e), \"Handlers map can contain only effects as keys\")));\n  }\n\n  return i;\n}\n\nfunction N(e, _ref10) {\n  let {\n    values: t\n  } = _ref10;\n  r(he(t), 'values property should be an object');\n  let n,\n      a,\n      l,\n      i = I(t),\n      s = Object.getOwnPropertyNames(i),\n      f = [],\n      u = [];\n  T(e) ? (n = e, l = 1, r(n.cloneOf, 'scope should be created from domain'), a = K(n.cloneOf)) : L(e) ? a = K(e) : r(0, 'first argument of hydrate should be domain or scope'), A(a, (e, t) => {\n    H(s, t) && (G(f, e), G(u, i[t]));\n  }), o({\n    target: f,\n    params: u,\n    scope: n\n  }), l && Object.assign(n.sidValuesMap, i);\n}\n\nfunction O(e) {\n  let {\n    scope: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  r(t || Ge, 'scopeBind cannot be called outside of forked .watch');\n  let n = t || Ge;\n  return B(e) ? t => {\n    let r = g();\n    return o({\n      target: e,\n      params: {\n        params: t,\n        req: r\n      },\n      scope: n\n    }), r.req;\n  } : t => (o({\n    target: e,\n    params: t,\n    scope: n\n  }), t);\n}\n\nfunction F(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let a = n.ignore ? n.ignore.map(_ref11 => {\n    let {\n      sid: e\n    } = _ref11;\n    return e;\n  }) : [],\n      o = {};\n  return e(t.sidValuesMap, (e, r) => {\n    if (H(a, r)) return;\n    let n = t.sidIdMap[r];\n    o[r] = n && n in t.reg ? t.reg[n].current : e;\n  }), 'onlyChanges' in n && !n.onlyChanges && (r(t.cloneOf, 'scope should be created from domain'), A(K(t.cloneOf), (e, r) => {\n    r in o || H(a, r) || ne(e, 'isCombine') || 'ignore' === ne(e, 'serialize') || (o[r] = t.getState(e));\n  })), o;\n}\n\nlet D = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    R = 'map',\n    z = 'stack',\n    _ = e => (ye(e) || he(e)) && 'kind' in e;\n\nconst P = e => t => _(t) && t.kind === e;\n\nlet V = P(\"store\"),\n    E = P(\"event\"),\n    B = P(\"effect\"),\n    L = P(\"domain\"),\n    T = P(\"scope\");\nvar W = {\n  __proto__: null,\n  unit: _,\n  store: V,\n  event: E,\n  effect: B,\n  domain: L,\n  scope: T\n};\n\nlet H = (e, t) => e.includes(t),\n    U = (e, t) => {\n  let r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n},\n    G = (e, t) => e.push(t),\n    J = (e, t, r) => !e && console.error(`${t} is deprecated${r ? `, use ${r} instead` : ''}`),\n    K = e => e.graphite || e,\n    Q = e => e.family.owners,\n    X = e => e.family.links,\n    Y = e => e.stateRef,\n    Z = e => e.value,\n    ee = e => e.subscribers,\n    te = e => e.parent,\n    re = e => e.scope,\n    ne = (e, t) => K(e).meta[t],\n    ae = (e, t, r) => K(e).meta[t] = r,\n    oe = e => e.compositeName;\n\nconst le = () => {\n  let e = 0;\n  return () => \"\" + ++e;\n};\n\nlet ie = le(),\n    se = le(),\n    fe = le(),\n    ue = null,\n    ce = () => ue && ue.template,\n    de = e => (e && ue && ue.sidRoot && (e = `${ue.sidRoot}|${e}`), e),\n    pe = _ref12 => {\n  let {\n    sid: e,\n    name: t,\n    loc: r,\n    method: o,\n    fn: l\n  } = _ref12;\n  return n(a({\n    meta: {\n      sidRoot: de(e),\n      name: t,\n      loc: r,\n      method: o\n    }\n  }), l);\n},\n    me = (e, r) => {\n  let n = K(e);\n  t(r, e => {\n    let t = K(e);\n    \"domain\" !== n.family.type && (t.family.type = \"crosslink\"), G(Q(t), n), G(X(n), t);\n  });\n},\n    ge = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (Array.isArray(e) ? e : [e]).flat().map(K);\n},\n    he = e => 'object' == typeof e && null !== e,\n    ye = e => 'function' == typeof e,\n    be = e => void 0 === e,\n    ve = e => r(he(e) || ye(e), 'expect first argument be an object');\n\nconst ke = (e, t, n, a) => r(!(!he(e) && !ye(e) || !('family' in e) && !('graphite' in e)), `${t}: expect ${n} to be a unit (store, event or effect)${a}`);\n\nlet we = (e, r, n) => {\n  Array.isArray(e) ? t(e, (e, t) => ke(e, r, `${t} item of ${n}`, '')) : ke(e, r, n, ' or array of units');\n},\n    xe = function (e, r) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"target\";\n  return t(ge(r), t => J(!ne(t, 'derived'), `${e}: derived unit in \"${n}\"`, \"createEvent/createStore\"));\n},\n    Se = (e, _ref13, _ref14) => {\n  let {\n    fn: t\n  } = _ref13;\n  let {\n    a: r\n  } = _ref14;\n  return t(e, r);\n},\n    $e = (e, _ref15, _ref16) => {\n  let {\n    fn: t\n  } = _ref15;\n  let {\n    a: r\n  } = _ref16;\n  return t(r, e);\n},\n    Ce = (e, _ref17) => {\n  let {\n    fn: t\n  } = _ref17;\n  return t(e);\n};\n\nconst Me = (e, t, r, n) => {\n  let a = {\n    id: se(),\n    type: e,\n    data: t\n  };\n  return r && (a.order = {\n    priority: r\n  }, n && (a.order.barrierID = ++je)), a;\n};\n\nlet je = 0,\n    Ae = _ref18 => {\n  let {\n    from: e = \"store\",\n    store: t,\n    target: r,\n    to: n = r ? \"store\" : z,\n    batch: a,\n    priority: o\n  } = _ref18;\n  return Me('mov', {\n    from: e,\n    store: t,\n    to: n,\n    target: r\n  }, o, a);\n},\n    Ie = _ref19 => {\n  let {\n    fn: e,\n    batch: t,\n    priority: r,\n    safe: n = 0,\n    filter: a = 0,\n    pure: o = 0\n  } = _ref19;\n  return Me('compute', {\n    fn: e,\n    safe: n,\n    filter: a,\n    pure: o\n  }, r, t);\n},\n    qe = _ref20 => {\n  let {\n    fn: e\n  } = _ref20;\n  return Ie({\n    fn: e,\n    priority: \"effect\"\n  });\n},\n    Ne = (e, t, r) => Ie({\n  fn: e,\n  safe: 1,\n  filter: t,\n  priority: r && \"effect\"\n}),\n    Oe = (e, t, r) => Ae({\n  store: e,\n  to: t ? z : \"a\",\n  priority: r && \"sampler\",\n  batch: 1\n}),\n    Fe = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Ce;\n  let t = arguments.length > 1 ? arguments[1] : undefined;\n  return Ie({\n    fn: e,\n    pure: 1,\n    filter: t\n  });\n},\n    De = {\n  mov: Ae,\n  compute: Ie,\n  filter: _ref21 => {\n    let {\n      fn: e,\n      pure: t\n    } = _ref21;\n    return Ie({\n      fn: e,\n      filter: 1,\n      pure: t\n    });\n  },\n  run: qe\n},\n    Re = e => ({\n  id: se(),\n  current: e\n}),\n    ze = _ref22 => {\n  let {\n    current: e\n  } = _ref22;\n  return e;\n},\n    _e = (e, t) => {\n  e.before || (e.before = []), G(e.before, t);\n},\n    Pe = null;\n\nconst Ve = (e, t) => {\n  if (!e) return t;\n  if (!t) return e;\n  let r;\n  return (e.v.type === t.v.type && e.v.id > t.v.id || He(e.v.type) > He(t.v.type)) && (r = e, e = t, t = r), r = Ve(e.r, t), e.r = e.l, e.l = r, e;\n},\n      Ee = [];\n\nlet Be = 0;\n\nfor (; Be < 6;) G(Ee, {\n  first: null,\n  last: null,\n  size: 0\n}), Be += 1;\n\nconst Le = () => {\n  for (let e = 0; e < 6; e++) {\n    let t = Ee[e];\n\n    if (t.size > 0) {\n      if (3 === e || 4 === e) {\n        t.size -= 1;\n        let e = Pe.v;\n        return Pe = Ve(Pe.l, Pe.r), e;\n      }\n\n      1 === t.size && (t.last = null);\n      let r = t.first;\n      return t.first = r.r, t.size -= 1, r.v;\n    }\n  }\n},\n      Te = (e, t, r, n, a, o) => We(0, {\n  a: null,\n  b: null,\n  node: r,\n  parent: n,\n  value: a,\n  page: t,\n  scope: o\n}, e),\n      We = function (e, t, r) {\n  let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let a = He(r),\n      o = Ee[a],\n      l = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: n\n    },\n    l: null,\n    r: null\n  };\n  3 === a || 4 === a ? Pe = Ve(Pe, l) : (0 === o.size ? o.first = l : o.last.r = l, o.last = l), o.size += 1;\n},\n      He = e => {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case 'read':\n      return 2;\n\n    case \"barrier\":\n      return 3;\n\n    case \"sampler\":\n      return 4;\n\n    case \"effect\":\n      return 5;\n\n    default:\n      return -1;\n  }\n},\n      Ue = new Set();\n\nlet Ge,\n    Je = 1,\n    Ke = 0,\n    Qe = 0,\n    Xe = null,\n    Ye = e => {\n  Ge = e;\n},\n    Ze = e => {\n  Xe = e;\n};\n\nconst et = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = te(e);\n\n    if (e) return e;\n  }\n\n  return null;\n};\n\nlet tt = (e, t, r, n, a) => {\n  let o = et(e, n.id);\n  return o ? o.reg[n.id] : t ? (rt(t, n, a), t.reg[n.id]) : n;\n},\n    rt = (e, r, n, a, o) => {\n  let l = e.reg,\n      i = r.sid;\n  if (l[r.id]) return;\n  let s = {\n    id: r.id,\n    current: r.current\n  };\n  if (i && i in e.sidValuesMap && !(i in e.sidIdMap)) s.current = e.sidValuesMap[i];else if (r.before && !o) {\n    let o = 0,\n        i = n || !r.noInit || a;\n    t(r.before, t => {\n      switch (t.type) {\n        case R:\n          {\n            let r = t.from;\n\n            if (r || t.fn) {\n              r && rt(e, r, n, a);\n              let o = r && l[r.id].current;\n              i && (s.current = t.fn ? t.fn(o) : o);\n            }\n\n            break;\n          }\n\n        case 'field':\n          o || (o = 1, s.current = Array.isArray(s.current) ? [...s.current] : { ...s.current\n          }), rt(e, t.from, n, a), i && (s.current[t.field] = l[l[t.from.id].id].current);\n      }\n    });\n  }\n  i && (e.sidIdMap[i] = r.id), l[r.id] = s;\n};\n\nconst nt = (e, t, r) => {\n  try {\n    return t(Z(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nlet at = function (t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return he(t) && (at(t.or, r), e(t, (e, t) => {\n    be(e) || 'or' === t || 'and' === t || (r[t] = e);\n  }), at(t.and, r)), r;\n};\n\nconst ot = (e, t) => {\n  U(e.next, t), U(Q(e), t), U(X(e), t);\n},\n      lt = (e, t, r) => {\n  let n;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  let a = X(e);\n\n  for (; n = a.pop();) ot(n, e), (t || r && 'sample' !== ne(e, 'op') || \"crosslink\" === n.family.type) && lt(n, t, 'on' !== ne(n, 'op') && r);\n\n  for (a = Q(e); n = a.pop();) ot(n, e), r && \"crosslink\" === n.family.type && lt(n, t, 'on' !== ne(n, 'op') && r);\n},\n      st = e => e.clear();\n\nlet ft = function (e) {\n  let {\n    deep: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), V(e)) st(ee(e));else if (L(e)) {\n    r = 1;\n    let t = e.history;\n    st(t.events), st(t.effects), st(t.stores), st(t.domains);\n  }\n  lt(K(e), !!t, r);\n},\n    ut = e => {\n  let t = () => ft(e);\n\n  return t.unsubscribe = t, t;\n},\n    ct = (e, t, r, n, o) => a({\n  node: r,\n  parent: e,\n  child: t,\n  scope: {\n    fn: o\n  },\n  meta: {\n    op: n\n  },\n  family: {\n    owners: [e, t],\n    links: t\n  },\n  regional: 1\n}),\n    dt = e => {\n  let t = 'forward',\n      [{\n    from: r,\n    to: n\n  }, o] = f(e, 1);\n  return we(r, t, '\"from\"'), we(n, t, '\"to\"'), xe(t, n, 'to'), ut(a({\n    parent: r,\n    child: n,\n    meta: {\n      op: t,\n      config: o\n    },\n    family: {},\n    regional: 1\n  }));\n},\n    pt = (e, t) => (r(ye(t), '.watch argument should be a function'), ut(a({\n  scope: {\n    fn: t\n  },\n  node: [qe({\n    fn: Ce\n  })],\n  parent: e,\n  meta: {\n    op: 'watch'\n  },\n  family: {\n    owners: e\n  },\n  regional: 1\n}))),\n    mt = function (e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n  te(e) && te(e).hooks[r](t);\n},\n    gt = (e, t, r, n) => {\n  let a = \"domain\" === e,\n      o = ie(),\n      l = at({\n    or: n,\n    and: 'string' == typeof r ? {\n      name: r\n    } : r\n  }),\n      {\n    parent: i = null,\n    sid: f = null,\n    named: u = null\n  } = l,\n      c = u || l.name || (a ? '' : o),\n      d = s(c, i),\n      p = {\n    op: t.kind = e,\n    name: t.shortName = c,\n    sid: t.sid = de(f),\n    named: u,\n    unitId: t.id = o,\n    serialize: l.serialize,\n    derived: l.derived,\n    config: l\n  };\n\n  if (t.parent = i, t.compositeName = d, t.defaultConfig = l, t.thru = e => (J(0, 'thru', 'js pipe'), e(t)), t.getType = () => d.fullName, !a) {\n    t.subscribe = e => (ve(e), t.watch(ye(e) ? e : t => e.next && e.next(t))), t[D] = () => t;\n    let e = ce();\n    e && (p.nativeTemplate = e);\n  }\n\n  return p;\n},\n    ht = e => c({\n  named: e\n});\n\nconst yt = (e, t, r, n) => {\n  let a;\n  he(r) && (a = r, r = r.fn);\n  let o = c({\n    name: `${e.shortName} \\u2192 *`,\n    derived: 1,\n    and: a\n  });\n  return ct(e, o, n, t, r), o;\n},\n      bt = (e, t, r, n, a) => {\n  let o = Y(t),\n      l = Ae({\n    store: o,\n    to: \"a\",\n    priority: 'read'\n  });\n  r === R && (l.data.softRead = 1);\n  let i = [l, Fe(n)];\n  return u('storeOnMap', o, i, V(e) && Y(e)), ct(e, t, i, r, a);\n},\n      vt = (t, n, a, o, i) => {\n  let s = t ? e => e.slice() : e => ({ ...e\n  }),\n      f = t ? [] : {},\n      c = s(f),\n      p = Re(c),\n      m = Re(1);\n  p.type = t ? 'list' : 'shape', p.noInit = 1, u('combineBase', p, m);\n  let g = d(c, {\n    name: l(a),\n    derived: 1,\n    and: o\n  }),\n      h = Y(g);\n  h.noInit = 1, ae(g, 'isCombine', 1);\n  let y = Oe(p);\n  y.order = {\n    priority: 'barrier'\n  };\n  let b = [Ne((e, t, r) => (r.scope && !r.scope.reg[p.id] && (r.c = 1), e)), y, Ae({\n    store: m,\n    to: 'b'\n  }), Ne((e, _ref23, r) => {\n    let {\n      key: t\n    } = _ref23;\n    if (r.c || e !== r.a[t]) return n && r.b && (r.a = s(r.a)), r.a[t] = e, 1;\n  }, 1), Ae({\n    from: \"a\",\n    target: p\n  }), Ae({\n    from: \"value\",\n    store: 0,\n    target: m\n  }), Ae({\n    from: \"value\",\n    store: 1,\n    target: m,\n    priority: \"barrier\",\n    batch: 1\n  }), Oe(p, 1), i && Fe()];\n  return e(a, (e, t) => {\n    if (!V(e)) return r(!_(e) && !be(e), `combine expects a store in a field ${t}`), void (c[t] = f[t] = e);\n    f[t] = e.defaultState, c[t] = e.getState();\n    let n = ct(e, g, b, 'combine', i);\n    n.scope.key = t;\n    let a = Y(e);\n    _e(p, {\n      type: 'field',\n      field: t,\n      from: a\n    }), u('combineField', a, n);\n  }), g.defaultShape = a, _e(h, {\n    type: R,\n    from: p,\n    fn: i\n  }), ce() || (g.defaultState = i ? h.current = i(c) : f), g;\n};\n\nlet kt = (e, t, r) => {\n  try {\n    return [1, e(...r)];\n  } catch (e) {\n    return t(e), [0, null];\n  }\n},\n    wt = (e, t, r, n, a) => l => o({\n  target: [n, xt],\n  params: [r ? {\n    status: 'done',\n    params: e,\n    result: l\n  } : {\n    status: 'fail',\n    params: e,\n    error: l\n  }, {\n    value: l,\n    fn: r ? t.rs : t.rj\n  }],\n  defer: 1,\n  page: a.page,\n  scope: re(a)\n});\n\nconst xt = a({\n  node: [qe({\n    fn: _ref24 => {\n      let {\n        fn: e,\n        value: t\n      } = _ref24;\n      return e(t);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n}),\n      St = ['source', 'clock', 'target'],\n      $t = (e, t) => e + `: ${t} should be defined`;\n\nlet Ct = (e, t, n, a, o, l, i, s, f, m, g, h) => {\n  let y = !!o;\n  r(!be(n) || !be(t), $t(e, 'either source or clock'));\n  let b = 0;\n  be(n) ? b = 1 : _(n) || (n = p(n)), be(t) ? t = n : (we(t, e, 'clock'), Array.isArray(t) && (t = w(t))), b && (n = t), s || i || (i = n.shortName);\n  let v = 'none';\n  (g || a) && (_(a) ? v = 'unit' : (r(ye(a), '`filter` should be function or unit'), v = 'fn')), o ? (we(o, e, 'target'), xe(e, o)) : 'none' === v && m && V(n) && V(t) ? o = d(l ? l(ze(Y(n)), ze(Y(t))) : ze(Y(n)), {\n    name: i,\n    sid: h,\n    or: s\n  }) : (o = c({\n    name: i,\n    derived: 1,\n    or: s\n  }), u('sampleTarget', K(o)));\n  let k = Re(),\n      x = [];\n\n  if ('unit' === v) {\n    let [r, n] = jt(a, o, t, k, e);\n    x = [...Mt(n), ...Mt(r)];\n  }\n\n  let [S, $] = jt(n, o, t, k, e);\n  return me(n, [ct(t, o, [u('sampleSourceLoader'), Ae({\n    from: z,\n    target: k\n  }), ...Mt($), Oe(S, 1, f), ...x, Oe(k), 'fn' === v && Fe((e, t, _ref25) => {\n    let {\n      a: r\n    } = _ref25;\n    return a(e, r);\n  }, 1), l && Fe(Se), u('sampleSourceUpward', y)], e, l)]), o;\n};\n\nconst Mt = e => [Oe(e), Ne((e, t, _ref26) => {\n  let {\n    a: r\n  } = _ref26;\n  return r;\n}, 1)],\n      jt = (e, t, r, n, o) => {\n  let l = V(e),\n      i = l ? Y(e) : Re(),\n      s = Re(l);\n  return l || a({\n    parent: e,\n    node: [Ae({\n      from: z,\n      target: i\n    }), Ae({\n      from: \"value\",\n      store: 1,\n      target: s\n    })],\n    family: {\n      owners: [e, t, r],\n      links: t\n    },\n    meta: {\n      op: o\n    },\n    regional: 1\n  }), u('sampleSource', s, i, n), [i, s];\n},\n      At = (e, t, r, n) => {\n  let a = e[t];\n  a && o({\n    target: a,\n    params: Array.isArray(a) ? a.map(() => r) : r,\n    defer: 1,\n    stack: n\n  });\n},\n      It = \"22.2.0\";\n\nexport { j as allSettled, y as attach, ft as clearNode, p as combine, b as createApi, v as createDomain, h as createEffect, c as createEvent, a as createNode, d as createStore, m as createStoreObject, q as fork, dt as forward, k as fromObservable, $ as guard, N as hydrate, W as is, o as launch, w as merge, C as restore, S as sample, O as scopeBind, F as serialize, i as setStoreName, M as split, De as step, It as version, pe as withFactory, n as withRegion };","map":{"version":3,"mappings":"AAAO,SAASA,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,OAEK,IAAMC,CAFXD,IAEkBD,CAFlBC,EAGEA,EAAGD,EAAIE,CAAJF,CAAHC,EAAaC,CAAbD;AAwBG;;AAAA,SAASE,CAAT,CAAiBC,CAAjB,EAAuBC,CAAvB,EAAuBA;AAC5BD,IAAKD,OAALC,CAAaC,CAAbD;AC9BK;;AAAA,SAASE,CAAT,CAAgBC,CAAhB,EAAoCC,CAApC,EAAoCA;AAAAA,OACpCD,CADoCC,EACzB,MAAMC,MAAMD,CAANC,CAAN;ACoBX;;AAAA,SAASC,CAAT,CAAoBC,CAApB,EAA0BV,CAA1B,EAA0BA;AAC/BW,OAAc;AACZC,YAAQD,EADI;AAEZE,WAAOH,CAFK;AAGZI,cAAUC,GAAQL,CAARK,EAAc,UAAdA,KAA6BC,IAH3B;AAIZC,aAASF,GAAQL,CAARK,EAAc,SAAdA,KAA6BJ,MAAeA,GAAYM;AAJrD,GAAdN;;AAImEM;AAAAA,WAG1DjB,GAH0DiB;AAG1DjB,GAH0DiB,SAG1DjB;AAEPW,SAAcO,GAAUP,EAAVO,CAAdP;AAAwBA;ACnBrB;;AAAA,SAASQ,CAAT,GA4BH;AAAA,MA5BYA;AAAWC,UACzBA,IAAO,EADOD;AAAWE,UAEzBA,CAFcF;AAAWG,YAGzBA,CAHcH;AAAWP,YAIzBA,IAASS,KAAQC,CAJHH;AAAWI,QAKzBA,CALcJ;AAAWK,YAMzBA,CANcL;AAAWM,WAOzBA,IAAQF,KAAMC,CAPAL;AAAWO,WAQzBA,IAAQ,EARMP;AAAWQ,UASzBA,IAAO,EATOR;AAUdS,YAAQC,IAAY;AAACC,YAAM;AAAP,KAVNX;AAAWY,cAWzBA;AAXcZ,GA4BZ;AAAA,MACIa,IAAUC,GAAYrB,CAAZqB,CADd;AAAA,MAEIC,IAAQD,GAAYJ,EAAUK,KAAtBD,CAFZ;AAAA,MAGIE,IAASF,GAAYJ,EAAUM,MAAtBF,CAHb;AAAA,MAIIG,IAAa,EAJjB;AAKFlC,IAAQkB,CAARlB,EAAcmC,KAAQA,KAAQC,EAAIF,CAAJE,EAASD,CAATC,CAA9BpC;AAAuCmC,MACjCE,IAAe;AACnBC,QAAIC,IADe;AAEnBL,UAFmB;AAGnBM,UAAMT,GAAYR,CAAZQ,CAHa;AAInBN,WAJmB;AAKnBD,YALmB;AAMnBE,YAAQ;AACNE,YAAMD,EAAUC,IAAVD,IC/Ca,WD8Cb;AAENK,cAFM;AAGNC;AAHM;AANW,GADkBE;AAUnCF,SAGJjC,EAAQgC,CAARhC,EAAeyC,KAAQL,EAAIM,EAAUD,CAAVC,CAAJN,EAAqBC,CAArBD,CAAvBpC,GACAA,EAAQiC,CAARjC,EAAgB2C,KAASP,EAAIQ,EAASD,CAATC,CAAJR,EAAqBC,CAArBD,CAAzBpC,CADAA,EAEAA,EAAQ8B,CAAR9B,EAAiBoB,KAAUgB,EAAIhB,EAAOoB,IAAXJ,EAAiBC,CAAjBD,CAA3BpC,CAFAA,EAGI6B,KAAYpB,EAAZoB,IACFgB,GAAIC,EAASrC,EAATqC,CAAJD,EAA2B,CAACR,CAAD,CAA3BQ,CAJF7C,EAMOqC,CATHJ;AEiMC;;AAAA,SAASc,CAAT,CAAgBvC,CAAhB,EAAsBwC,CAAtB,EAAgCC,CAAhC,EAAgCA;AAAAA,MACjCC,IAAgBC,EADiBF;AAAAA,MAEjCG,IAAiB,IAFgBH;AAAAA,MAGjCI,IAAoBC,EAHaL;AAGbK,MACpB9C,EAAKc,MAALd,KACFwC,IAAUxC,EAAK+C,MAAfP,EACAC,IAASzC,EAAKgD,KADdR,EAEAE,IAAgB,UAAU1C,CAAV,GAAiBA,EAAKiD,IAAtB,GAA6BP,CAF7CF,EAGIxC,EAAIkD,KAAJlD,KAAa4C,IAAiB5C,EAAIkD,KAAlClD,CAHJwC,EAIAK,IAAoBM,GAAYnD,CAAZmD,KAAqBN,CAJzCL,EAKAxC,IAAOA,EAAKc,MANVd,GAQA6C,KAAqBC,EAArBD,IAAiCA,MAAsBC,EAAvDD,KACFC,KAAW,IADTD,CARA7C,EAWAoD,MAAMC,OAAND,CAAcpD,CAAdoD,CAZoBN,EAYN9C,KACX,IAAIsD,IAAI,CADGtD,EACAsD,IAAItD,EAAKuD,MADTvD,EACiBsD,GADjBtD,EAEdwD,GACE,MADFA,EAEEd,CAFFc,EAGEC,EAASzD,EAAKsD,CAALtD,CAATyD,CAHFD,EAIEZ,CAJFY,EAKEhB,EAAQc,CAARd,CALFgB,EAMEX,CANFW,EAdoBV,KAwBtBU,GACE,MADFA,EAEEd,CAFFc,EAGEC,EAASzD,CAATyD,CAHFD,EAIEZ,CAJFY,EAKEhB,CALFgB,EAMEX,CANFW;AAMEX,MAGAJ,MAAWiB,EAHXb,EAGmB;AAAA,MAUnBc,CAVmB;AAAA,MAWnBC,CAXmB;AAAA,MAYnBlD,CAZmB;AAAA,MAanBP,CAbmB;AAAA,MAcnB8C,CAdmB;AAAA,MAenBY,CAfmB;AAAA,MAEjBC,IAAmB;AACvBJ,cADuB;AAEvBf,mBAFuB;AAGvB3B,WAAO8B,EAHgB;AAIvBiB,eAJuB;AAKvBC;AALuB,GAFF;AASvBN,OAAS,CAATA;;AAOAO,KAAY,OAAQ9D,IAAQ+D,IAAhB,GAA8B;AAAA;AAClCC,WAACA,CADiC;AAClCjB,aAAMA,CAD4B;AAClC9B,YAAaA;AADqB,QACbjB,CADa;AAExCO,QAAOwC,EAAMxC,IAAbA,EACAiC,KAAcM,IAAOC,EAAMD,IAD3BvC,EAEAoC,KAAWK,GAAYD,CAAZC,CAFXzC,EAGIuC,IAAMY,IAAMZ,EAAKY,GAAjBZ,GACKH,OAAUe,IAAMf,GAASe,GAAzBf,CAJTpC;AAIkCmD,QAE5BO,MAAenB,CAFaY;AAAAA,QAG5BQ,MAAgBvB,EAHYe;AAAAA,QAI5BS,IAAe;AACnBC,YAAM,CADa;AAEnBvD,aAAON,EAAKM;AAFO,KAJa6C;AAQlCF,QAAOC,IAAO,CAAdD;;AAAc,SACT,IAAIa,IAAQL,CADH,EACQK,IAAQ9D,EAAKgB,GAALhB,CAAS6C,MAAjBiB,IAAiBjB,CAAWI,CADpC,EAC0Ca,GAD1C,EACmD;AAAA,UACzDC,IAAO/D,EAAKgB,GAALhB,CAAS8D,CAAT9D,CADkD;;AACzC8D,UAClBC,EAAKC,KADaF,EACN;AAAA;AACRG,oBAACA,CADO;AACRC,qBAAWA;AADH,YACgBH,EAAKC,KADrB;AAAA,YAER5C,IAAK8C,IACP3B,IACG,GAAEA,EAAK4B,UAAUD,GADpB3B,GAEE2B,CAHKA,GAIP,CANU;;AAMV,YACAJ,MAAUL,CAAVK,IAAiBpD,MAASuD,CAD1B,EACoC;AAClCC,cACGE,GAASC,GAATD,CAAahD,CAAbgD,MACHA,GAASlD,GAATkD,CAAahD,CAAbgD,GACAE,GAASR,CAATQ,EAAgB9B,CAAhB8B,EAAuBL,CAAvBK,EAAiCJ,CAAjCI,CAFGF,CADHF,GAMFI,GAASR,CAATQ,EAAgB9B,CAAhB8B,EAAuBL,CAAvBK,CANEJ;AAMqBD,mBAEhBV,CAFgBU;AAI3BC;;AAAAA,aAAaE,GAASG,MAATH,CAAgBhD,CAAhBgD,CAAbF;AAA6B9C;;AAAAA,cAEvB2C,EAAKrD,IAFkBU;AAElBV,aACN,KADMA;AACN;AAAA,gBAECjB,CAFD;AAAA,gBACG+E,IAAOT,EAAKS,IADf;;AACeA,oBAGVA,EAAKvE,IAHKuE;AAGLvE,mBACNwE,CADMxE;AACCR,oBAAQmC,EAASY,CAATZ,CAARnC;AAAiB+C;;AAAAA,mBD1UpB,GC0UoBA;AD1UpB,mBC4UJ,GD5UI;AC6UP/C,oBAAQ+C,EAAMgC,EAAKvE,IAAXuC,CAAR/C;AAAmBQ;;AAAAA,mBDhVZ,OCgVYA;AAETR,oBAAQ+E,EAAKE,KAAbjF;AAAaiF;;AAAAA,mBD5VhB,OC4VgBA;AD5VhB,oBC8VHvB,MAAQA,EAAIqB,EAAKE,KAALF,CAAWpD,EAAf+B,CD9VL,EC8VoB/B,IAErBsC,CAFqBtC,EAET;AAAA,sBACRuD,IAAaC,GAAcrC,CAAdqC,EAAoBJ,EAAKE,KAALF,CAAWpD,EAA/BwD,CADL;AAEdpC,oBAAMD,IAANC,GAAaD,IAAOoC,CAApBnC,EACImC,IACFxB,IAAMwB,EAAWxB,GADfwB,GAEOhB,KACTkB,GAAezC,EAAfyC,EAA0BL,EAAKE,KAA/BG,EAAsC,CAAtCA,EAA6C,CAA7CA,EAAmDL,EAAKM,QAAxDD,GACA1B,IAAMf,GAAUe,GAFPQ,IAITR,SAAM4B,CAPRvC;AAOQuC,iBAXe3D,MAaduC,KAETkB,GAAezC,EAAfyC,EAA0BL,EAAKE,KAA/BG,EAAsC,CAAtCA,EAA6C,CAA7CA,EAAmDL,EAAKM,QAAxDD,CAFSlB;AAUblE,oBAAQuF,GAAQ7B,KAAMA,EAAIqB,EAAKE,KAALF,CAAWpD,EAAf+B,CAANA,IAAyCqB,EAAKE,KAAtDM,CAARvF;AAlCc+E;;AAkCgDE,oBAI1DF,EAAKrE,EAJqDuE;AAIrDvE,mBACNsE,CADMtE;AACCqC,kBAAM/C,KAAN+C,GAAc/C,CAAd+C;AAAc/C;;AAAAA,mBD7WjB,GC6WiBA;AD7WjB,mBC+WJ,GD/WI;ACgXP+C,kBAAMgC,EAAKrE,EAAXqC,IAAiB/C,CAAjB+C;AAAiB/C;;AAAAA,mBD7XV,OC6XUA;AAGjBwF,mBAAW1C,CAAX0C,EAAiB7C,EAAjB6C,EAA2BjF,CAA3BiF,EAAiCT,EAAKpE,MAAtC6E,EAA8CC,OAA9CD,GAAwDxF,CAAxDwF;AAX8DP;;AAWNjF;AAAAA;;AAAAA,aAKzD,SALyDA;AAKzD,cACG+E,IAAOT,EAAKS,IADf;;AACeA,cACdA,EAAKxF,EADSwF,EACL;AACXnB,iBAAkC,YAAxB1D,GAAQK,CAARL,EAAc,IAAdA,CAAV0D,EACAC,KAASkB,EAAKW,IADd9B;AACc8B,gBACRC,IAAoBZ,EAAKa,IAALb,GAAKa,CAC3B,GAAWb,EAAKxF,EADWqG,EACPzD,EAASY,CAATZ,CADOyD,EACUzB,EAAMtD,KADhB+E,EACuB7C,CADvB6C,CAALb,GAEtBc,GAAO1B,CAAP0B,EAAcd,EAAKxF,EAAnBsG,EAAuB9C,CAAvB8C,CAHUH;AAIVX,cAAKe,MAALf,GAMFtB,KAAQkC,CANNZ,GAQFhC,EAAM/C,KAAN+C,GAAc4C,CARZZ,EAUJnB,KAAUD,EAAiBC,OAVvBmB,EAWJlB,KAASF,EAAiBE,MAXtBkB;AAWsBlB;;AAzEDlC;;AA6E/B6B,UAAOW,EAAMC,IAAND,IAAcV,CAArBD;AAAqBC;;AAAAA,SAElBD,CAFkBC,EAEZ;AAAA,UACHsC,IAAa5D,EAASY,CAATZ,CADV;AAET9C,QAAQkB,EAAKsB,IAAbxC,EAAmB2G;AACjB3C,WACE,OADFA,EAEEP,CAFFO,EAGE2C,CAHF3C,EAIEN,CAJFM,EAKE0C,CALF1C,EAMEL,GAAYD,CAAZC,CANFK;AAMcN,OAPhB1D;AAOgB0D,UAGVJ,IAAWK,GAAYD,CAAZC,CAHDD;;AAGaA,UACzBJ,CADyBI,EACf;AACR7C,WAAQK,CAARL,EAAc,eAAdA,KACFmD,GACE,OADFA,EAEEP,CAFFO,EAGEV,EAASsD,OAHX5C,EAIEN,CAJFM,EAKE0C,CALF1C,EAMEV,CANFU,CADEnD,EASAA,GAAQK,CAARL,EAAc,aAAdA,KACFmD,GACE,OADFA,EAEEP,CAFFO,EAGEV,EAASuD,WAHX7C,EAIEN,CAJFM,EAKE0C,CALF1C,EAMEV,CANFU,CAVEnD;AAgBAyC,YAEEwD,IAAkBxD,EAASwD,eAATxD,CAAyBpC,EAAKoB,EAA9BgB,CAFpBA;AAGAwD,aACF9G,EAAQ8G,CAAR9G,EAAyB2G;AACvB3C,aACE,OADFA,EAEEP,CAFFO,EAGE2C,CAHF3C,EAIEN,CAJFM,EAKE0C,CALF1C,EAMEV,CANFU;AAMEV,SAPJtD,CADE8G;AAQExD;AAAAA;AAOZY;;AAAAA,OAASI,EAAiBJ,MAA1BA,EACAf,KAAcmB,EAAiBnB,WAD/Be,EAEAZ,KAAWK,GAAYW,CAAZX,CAFXO;ACzcK;;AAAA,SAAS6C,CAAT,CAAwBC,CAAxB,EAAmD;AAAA,MAAjBC,CAAiB;AAAA,MACpDC,IAAOD,IAAS,GADoC;AAAA,MAEpDE,IAAQ,EAF4C;AAAA,MAGpDrD,IAAI,CAHgD;AAGhD,SACRlE,EAAMoH,CAANpH,EAAgBY;AAEVsD,QAAI,EAAJA,KACU,QAARtD,CAAQ,KACV0G,KAAQC,CAARD,EACAA,KAAQE,EAAQ5G,CAAR4G,IACJC,GAAiB7G,CAAjB6G,EAA8CC,QAD1CF,GAEJ5G,EAAK+G,QAAL/G,EAJM,GAMZsD,KAAK,CANO,EAOZqD,IAAQ,IARNrD;AAQM,GAVZlE,GAaOsH,IAAO,GAdN;AAiBH;;AAAA,SAASM,CAAT,CAA6B5B,CAA7B,EAAkD6B,CAAlD,EAAkDA;AACvD7B,IAAM8B,SAAN9B,GAAkB6B,CAAlB7B,EACA+B,OAAOC,MAAPD,CAAcN,GAAiBzB,CAAjByB,CAAdM,EAAuCE,EAAWJ,CAAXI,EAAoB7G,GAAU4E,CAAV5E,CAApB6G,CAAvCF,CADA/B;AAUK;;AAAA,SAASiC,CAAT,CAAoBX,CAApB,EAAkCxG,CAAlC,EAAkCA;AAAAA,MACnCoH,CADmCpH;AAAAA,MAEnC4G,CAFmC5G;AAAAA,MAGjCgH,IAAYR,CAHqBxG;;AAGrBwG,MACbxG,CADawG,EAIX;AAAA,QACCa,IAAYV,GAAiB3G,CAAjB2G,CADb;AAEe,UAAhBH,EAAKnD,MAAW,IAClB+D,IAAOC,EAAUD,IAAjBA,EACAR,IAAWS,EAAUT,QAFH,KAIlBQ,IAAOC,EAAUD,IAAVC,CAAeC,MAAfD,CAAsB,CAACb,CAAD,CAAtBa,CAAPD,EACAR,IACgC,MAA9BS,EAAUT,QAAVS,CAAmBhE,MAAW,GAC1BmD,CAD0B,GAErBa,EAAUT,QAAVS,GAAqB,GAArBA,GAA2Bb,CARpB;AAQoBA,GAdxBA,MAEhBY,IAAuB,MAAhBZ,EAAKnD,MAAW,GAAI,EAAJ,GAAS,CAACmD,CAAD,CAAhCY,EACAR,IAAWJ,CADXY;;AACWZ,SAcN;AAACQ,gBAAD;AAAYJ,eAAZ;AAAsBQ;AAAtB,GAdMZ;AClCR;;AAAA,SAASe,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,MAEMC,IAAYD,IAAiBD,CAAjBC,GAAwBD,EAAK,CAALA,CAF1CC;AAGAE,KAAaD,CAAbC;AAAaD,MACTE,IAAWF,EAAUG,EADZH;AAAAA,MAEPI,IAAcJ,EAAUK,GAFjBL;;AAEiBK,MAC1BD,CAD0BC,EACb;AAAA,QACTC,IAAuBP,IAAiBK,CAAjBL,GAA+BK,EAAY,CAAZA,CAD7C;;AACyD,QAOnEG,GAASD,CAATC,KAAoC,SAASD,CAPsB,EASjE;AAAA,UAECE,IAASX,EAAoBO,CAApBP,EAAiCE,CAAjCF,CAFV;AAILC,UAAOU,EAAO,CAAPA,CAAPV,EACAI,IAAW,KAAIA,CAAJ;AAAIA,WAAaM,EAAO,CAAPA;AAAjB,OADXV;AACmC,KAdmC,MAQtEA,IAAOM,CAAPN;AAAOM;;AAAAA,SASJ,CAACN,CAAD,EAAOI,CAAP,CATIE;ACtBN;;AAAA,SAASK,CAAT,CACL5B,CADK,EAEFiB;AAAAA,MAIGtH,IAAWE,IAJdoH;;AAIcpH,MACbF,CADaE,EACH;AAAA,QACNZ,IAAKU,EAASkI,QAATlI,CAAkBqG,CAAlBrG,CADC;;AAAA,sCALXsH,CAKW;AALXA,OAKW;AAAA;;AACiBjB,QACzB/G,CADyB+G,EACrB,OAAO/G,EAAGU,CAAHV,EAAGU,GAAasH,CAAhBhI,CAAP;AAAuBgI;AC4H5B;;AAAA,SAASa,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,MAEMC,IAAS,UAAClG,CAAD;AAAA,uCAAsBkF,CAAtB;AAAsBA,OAAtB;AAAA;;AAAA,WACbiB,GACGtI,GAAQqI,CAARrI,EAAe,SAAfA,CADHsI,EAEE,uBAFFA,EAGE,aAHFA,GAKAA,GAAW3E,EAAX2E,EAAmB,8BAAnBA,EAAmD,uBAAnDA,CALAA,EAMIhG,KA/BR,EACE3C,CADF,EAEEI,CAFF,EAGEoC,CAHF,EAIEkF,CAJF,KAIEA;AAAAA,UAEMkB,IAAUjG,EAFhB+E;AAAAA,UAGIzE,IAAO,IAHXyE;AAGW,UACPtH,CADO,EACPA,KACF6C,IAAON,EADLvC,EAEK6C,KAAQA,EAAK7C,QAAL6C,KAAkB7C,CAF/BA,GAGA6C,IAAOzC,GAAUyC,CAAVzC,CAAPyC;AAGJ4F,SAAe5F,CAAf4F;AAAe5F,UACTpB,IAAS7B,EAAK8I,MAAL9I,CAAYwC,CAAZxC,EAAqB0H,CAArB1H,CADAiD;AACqByE,aACpCmB,GAAeD,CAAfC,GACOhH,CAF6B6F;AAE7B7F,KAjBT,EAgCwB6G,CAhCxB,EAgC+BtI,CAhC/B,EAgCyCoC,CAhCzC,EAgCkDkF,CAhClD,CA+BQ/E,GAGG+F,EAAMI,MAANJ,CAAalG,CAAbkG,EAAsBhB,CAAtBgB,CAVM;AAAA,GAFfD;AAAAA,MAcMrI,IAAWE,IAdjBmI;;AAciBnI,SACV6G,OAAOC,MAAPD,CAAcuB,CAAdvB,EAAqB;AAC1B4B,cAAUtI,EAAW;AACnBQ,YAAM+H,GL1JS,OK0JTA,EAAgBN,CAAhBM,EAAuBR,CAAvBQ,EAAqCP,CAArCO,CADa;AAEnB3H,gBAAU;AAFS,KAAXZ,CADgB;AAK1BqI,YAAO/F,MACLR,EAAO;AAACzB,cAAQ4H,CAAT;AAAgB3F,eAAhB;AAAwB/B,aAAO8B;AAA/B,KAAPP,GACOQ,CAFFA,CALmB;AAS1BkG,WAAQvJ,KAAkCwJ,GAAUR,CAAVQ,EAAiBxJ,CAAjBwJ,CAThB;AAU1BC,SAAMzJ,KAAiB0J,GAAYV,CAAZU,EAAmBC,CAAnBD,EAAwB1J,CAAxB0J,EAA4B,CAACE,IAAD,CAA5BF,CAVG;AAW1BnD,YAASvG,KACP0J,GAAYV,CAAZU,ELzJgB,QKyJhBA,EAA2B1J,EAAGA,EAAHA,GAAQA,CAARA,GAAaA,EAAGA,EAA3C0J,EAA+C,CAC7CE,GAAWC,EAAXD,EAAsB,CAAtBA,CAD6C,CAA/CF,CAZwB;AAe1BI,eAAY9J,KACV0J,GAAYV,CAAZU,EAAmB,WAAnBA,EAAgC1J,CAAhC0J,EAAoC,CAClCE,IADkC,EAElCG,GAAKtJ,MAAUuJ,GAAOvJ,CAAPuJ,CAAfD,EAA8B,CAA9BA,CAFkC,CAApCL,CAhBwB;;AAoB1BO,YAAQjK,CAARiK,EAAQjK;AAAAA,UACAkK,IAA2BrB,EAAY,cAASG,EAAMxB,SAA3BqB,EAAsC;AACrErI,gBAAQM,GAAUkI,CAAVlI;AAD6D,OAAtC+H,CAD3B7I;AAEcgJ,aAEpBL,EAAc,cAAdA,EAA8B5E,EAASmG,CAATnG,CAA9B4E,GACAwB,GAAeD,CAAfC,EAA6BnB,CAA7BmB,EAAoC,CAACP,IAAD,CAApCO,EAAoD,SAApDA,EAA+DnK,CAA/DmK,CADAxB,EAEAyB,GAAgBpB,CAAhBoB,EAAuBF,CAAvBE,CAFAzB,EAGOuB,CALalB;AAKbkB;;AA3BiB,GAArBzC,CADU7G;AAiCZ;;AAAA,SAASyJ,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,MAEMC,IAAaC,GAAeH,CAAfG,CAFnBF;AAAAA,MAGMG,IAAUC,GAAiB,SAAjBA,CAHhBJ;AAIA5B,IAAc,WAAdA,EAA2B6B,CAA3B7B;AAA2B6B,MACrBI,IAAeJ,EAAWpI,EADLoI;AAAAA,MAErB9E,IAAQ;AACZmF,iBAAa,IAAIC,GAAJ,EADD;AAEZJ,cAFY;AAGZJ,mBAHY;AAIZS,cAAUP,CAJE;;AAKZQ;AAAAA,UAEMC,CAFND;AAAAA,UACME,IAAYV,CADlBQ;;AACkBR,UAEZvH,EAFYuH,EAEC;AAAA,YACXjH,IAAON,EADI;;AACJA,eACJM,MAASA,EAAKY,GAALZ,CAASqH,CAATrH,CADLN,GAETM,IAAOzC,GAAUyC,CAAVzC,CAAPyC;;AAEEA,cAAM0H,IAAc1H,CAApBA;AAAoBA;;AAAAA,cAErB0H,CAFqB1H,IAENH,EAFMG,KAGxBsC,GAAezC,EAAfyC,EAAyB2E,CAAzB3E,EAAqC,CAArCA,GACAoF,IAAc7H,EAJUG,GAMtB0H,MAAaC,IAAYD,EAAY9G,GAAZ8G,CAAgBL,CAAhBK,CAAzBA,CANsB1H,EAOnByC,GAAQkF,CAARlF,CAPmBzC;AAOX2H,KApBL;;AAsBZC,cAAWC,KACTvI,EAAO;AACLzB,cAAQsE,CADH;AAELrC,cAAQ+H,CAFH;AAGL9H,aAAO,CAHF;AAILhC,aAAO8B;AAJF,KAAPP,CAvBU;AA6BZwI,WAAK;AAAA,yCAAIC,CAAJ;AAAIA,SAAJ;AAAA;;AAAA,aACHxL,EAAQwL,CAARxL,EAAeQ,KAAQoF,EAAM6F,EAAN7F,CAASpF,CAAToF,EAAe,MAAMA,EAAM4E,YAA3B5E,CAAvB5F,GACO4F,CAFJ;AAAA,KA7BO;AAiCZ6F,QAAE,CAACC,CAAD,EAAqCxL,CAArC,MACAyL,GAAcD,CAAdC,EAAuB,KAAvBA,EAA8B,gBAA9BA,GACAxC,GACGtI,GAAQ+E,CAAR/E,EAAe,SAAfA,CADHsI,EAEE,sBAFFA,EAGE,aAHFA,CADAwC,EAMA3L,EAAQ4D,MAAMC,OAAND,CAAc8H,CAAd9H,IAAyB8H,CAAzB9H,GAAmC,CAAC8H,CAAD,CAA3C1L,EAAsD4L;AACpDhG,QAAMiG,GAANjG,CAAUgG,CAAVhG,GACAkG,GAAelG,CAAfkG,EAAsBC,GAAtBD,CACEF,CADFE,EAEEE,GACEC,GAAYL,CAAZK,EAAqBrG,CAArBqG,EAA4B,IAA5BA,EAAkCC,EAAlCD,EAAiD/L,CAAjD+L,CADFD,CAFFF,CADAlG;AAIqD1F,KALvDF,CANA2L,EAeO/F,CAhBP,CAjCU;;AAmDZiG,QAAIrL,CAAJqL,EAAIrL;AAAAA,UACI2L,IAAsBL,GAAelG,CAAfkG,EAAsBM,GAAtBN,CAA0BtL,CAA1BsL,CAD1BtL;AACoDA,aAClD2L,MACFA,KACAL,GAAelG,CAAfkG,EAAsBrG,MAAtBqG,CAA6BtL,CAA7BsL,CAFEK,GAIGvG,CAL+CpF;AAK/CoF,KAzDG;;AA2DZ+D,QAAIzJ,CAAJyJ,EAA4C0C,CAA5C1C,EAA4C0C;AAAAA,UACtCC,CADsCD,EAWtCE,CAXsCF;AAEtC1D,SAASzI,CAATyI,MACF2D,IAASpM,CAAToM,EACApM,IAAMA,EAA4CA,EAFhDyI,GAIJQ,EACEe,GAAOmC,CAAPnC,CADFf,EAEE,8BAFFA,EAGE,cAHFA,CAJIR;AAOF,UAGI6D,IAAa5G,EAAMsF,QAANtF,EAHjB;AAIe9E,aAEfyL,IAAa,IAFEzL,GAGLoJ,GAAOsC,CAAPtC,MACVqC,IAAarM,EAAGsM,CAAHtM,EAAemM,CAAfnM,CADHgK,CAHKpJ;AAIauL,UAGxBI,IAAyBlC,EAAYgC,CAAZhC,EAAwB;AACrDrD,cAAO,GAAEtB,EAAM8B,oBADsC;AAErDgF,iBAAS,CAF4C;AAGrDjE,aAAK6D;AAHgD,OAAxB/B,CAHD8B;AAAAA,UAQxBM,IAAWV,GAAYrG,CAAZqG,EAAmBQ,CAAnBR,EAA+BpC,CAA/BoC,EAAoCW,EAApCX,EAAmD/L,CAAnD+L,CARaI;AAQsCnM,aACpE2M,GAASC,EAAcL,CAAdK,CAATD,EAAoC;AAClCjL,cAAMiI,CAD4B;AAElC3J,aAFkC;AAGlCiB,cAAMuJ;AAH4B,OAApCmC,GAKAC,EAAcL,CAAdK,EAA0BC,MAA1BD,GAAmC,CALnCD,EAMAhE,EAAc,UAAdA,EAA0B6B,CAA1B7B,EAAsC8D,CAAtC9D,CANAgE,EAOOJ,CAR6DvM;AAQ7DuM,KA5FG;;AA8FZhD,UAAMuD,CAANvD,EAAiBvJ,CAAjBuJ,EAAiBvJ;AAAAA,WACVA,CADUA,IACVA,CAAOkH,EAAQ4F,CAAR5F,CADGlH,EACiB;AAAA,YACxB+M,IAAevD,GAAU9D,CAAV8D,EAAiBsD,CAAjBtD,CADS;AACQsD,eACjCnE,EAAc,YAAdA,EAA4B6B,CAA5B7B,EAAwCmE,CAAxCnE,KACHmE,EAAUpH,EAAMsF,QAANtF,EAAVoH,CADGnE,EAGEoE,CAJ+BD;AAI/BC;;AAAAA,aAET9M,EAAO+M,GAAWhN,CAAXgN,CAAP/M,EAAuB,sCAAvBA,GACO6M,EAAUvD,KAAVuD,CAAgBhK,KAAW9C,EAAG0F,EAAMsF,QAANtF,EAAH1F,EAAqB8C,CAArB9C,CAA3B8M,CAHEC;AAG8CjK;;AAvG7C,GAFa0H;AAAAA,MA4GrBjJ,IAAO+H,GL3SM,OK2SNA,EAAgB5D,CAAhB4D,EAAuBiB,CAAvBjB,CA5GckB;AAAAA,MA6GrByC,IAAevH,EAAMwH,aAANxH,CAAoBuH,YA7GdzC;AA8G3B9E,IAAM2D,QAAN3D,GAAiB3E,EAAW;AAC1BO,WAAO;AAAC8J,aAAOZ,CAAR;AAAoBxK,UAAIiN;AAAxB,KADmB;AAE1BjM,UAAM,CACJ+I,GAAK,CAACoD,CAAD,EAAMC,CAAN,EAAS5J,CAAT,MACCA,EAAMlC,KAANkC,IAAMlC,CAAUkC,EAAMlC,KAANkC,CAAYW,GAAZX,CAAgBgH,EAAWpI,EAA3BoB,CAAhBA,KACFA,EAAM6J,CAAN7J,GAAU,CADRA,GAGG2J,CAJJ,CAALpD,CADI,EAOJuD,GAAK9C,CAAL8C,CAPI,EAQJvD,GAAK,CAACoD,CAAD,EAAMC,CAAN;AAAA,UAAMA;AAAIG,YAAJH;AAAOC;AAAPD,OAAN;AAAA,aAAaC,CAAQrD,GAAOmD,CAAPnD,CAARqD,KAAwBF,MAAQI,CAARJ,IAAaE,CAArCA,CAAb;AAAA,KAALtD,EAA2D,CAA3DA,CARI,EASJkD,KAAgBrD,GAAW8C,EAAX9C,EAA0B,CAA1BA,CATZ,EAUJ4D,GAAI;AAACvM,YAAMwE,CAAP;AAAcrE,cAAQoJ;AAAtB,KAAJgD,CAVI,CAFoB;AAc1BnM,WAAOqJ,CAdmB;AAe1BnJ,WAf0B;AAgB1BI,cAAU;AAhBgB,GAAXZ,CAAjB2E;AAgBY,MAEN+H,IAAqB9M,GAAQ+E,CAAR/E,EAAe,KAAfA,CAFf;AAE8B,SACtC8M,MACkC,aAAhC9M,GAAQ+E,CAAR/E,EAAe,WAAfA,CAAgC,IAClC+M,GAAQhI,CAARgI,EAAe,aAAfA,EAA8B,CAA9BA,CADkC,EAEpClD,EAAWiD,GAAXjD,GAAiBiD,CAHfA,GAKJxN,EACEU,GAAQ+E,CAAR/E,EAAe,SAAfA,KAAe,CAAeqJ,GAAOM,CAAPN,CADhC/J,EAEE,oDAFFA,CALIwN,EASJ9K,GAAI+C,CAAJ/C,EAAW,CAAC+H,CAAD,CAAX/H,CATI8K,EAUG/H,CAXmC;AC/SrC;;AAAA,SAASiI,CAAT,GAAoB3F;AAAAA;AAAAA;AAAAA;;AAAAA,MACrB4F,CADqB5F,EAErB6F,CAFqB7F,EAGrBoE,CAHqBpE;AAGrBoE,GACFpE,CADEoE,EACIA,CADJA,IACcrE,EAAoBC,CAApBD,CADdqE;AACkCpE,MASlC8F,CATkC9F;AAAAA,MAUlC+F,CAVkC/F;AAAAA,MAkClCgG,CAlCkChG;AAAAA,MAChCiG,IAAajG,EAAKA,EAAKnE,MAALmE,GAAc,CAAnBA,CADmBA;;AACA,MAClCgF,GAAWiB,CAAXjB,KACFa,IAAS7F,EAAKkG,KAALlG,CAAW,CAAXA,EAAW,CAAI,CAAfA,CAAT6F,EACAD,IAAUK,CAFRjB,IAIFa,IAAS7F,CAJPgF,EASkB,MAAlBa,EAAOhK,MAV2B,EAUb;AAAA,QACjBlE,IAAMkO,EAAO,CAAPA,CADW;AAKlB3G,MAASvH,CAATuH,MAcH4G,IAAmBnO,CAAnBmO,EACAC,IAAa,CAfV7G;AAeU;;AAAA,OAIZ6G,CAJY,KAQfD,IAAmBD,CAAnBC,EAKIF,CAbW,GAaF;AACXI,QAAgB,CAAhBA;AAAgB,QACVhO,IAAK4N,CADK;;AAEhBA,QAAU7N,KAAQC,KAAMD,CAANC,CAAlB4N;AAAwB7N;;AAAAA,SAG5BE,EAAOwI,GAASqF,CAATrF,CAAPxI,EAAmC,2BAAnCA,GACOkO,GACLzK,MAAMC,OAAND,CAAcoK,CAAdpK,CADKyK,EACSL,CACbE,CAFIG,EAGLL,CAHKK,EAIL/B,CAJK+B,EAKLP,CALKO,CAJqBpO;AA0GvB;;AAAA,SAASqO,CAAT,GAA8BpG;AAAAA,SACnCiB,EAAU,CAAVA,EAAiB,mBAAjBA,EAAsC,SAAtCA,GACO0E,eAF4B3F;AC7K9B;;AAAA,SAASqG,CAAT,GAASA;AAAAA,MAKRlM,IAAS,EALDkM;AAKC,SAKflM,EAAOmM,GAAPnM,GAAa,IAAIoM,OAAJ,CAAY,CAACC,CAAD,EAAKC,CAAL,KAAKA;AAC5BtM,MAAOqM,EAAPrM,GAAYqM,CAAZrM,EACAA,EAAOsM,EAAPtM,GAAYsM,CADZtM;AACYsM,GAFD,CAAbtM,EAIAA,EAAOmM,GAAPnM,CAAWuM,KAAXvM,CAAiBwM,QAAjBxM,CAJAA,EAKOA,CAVQ;ACSV;;AAAA,SAASyM,CAAT,CACL9F,CADK,EAELC,CAFK,EAELA;AAAAA,MAEM8F,IAAWhG,EACfmE,GAAWlE,CAAXkE,IAA2B;AAACY,aAAS9E;AAAV,GAA3BkE,GAAqDlE,CADtCD,EAEfE,CAFeF,CAFjBE;AAAAA,MAMM/H,IAAO+C,EAAS8K,CAAT9K,CANbgF;AAOA2E,KAAQ1M,CAAR0M,EAAc,IAAdA,EAAqBmB,EAASC,IAATD,GRrBD,QQqBpBnB,GAEAmB,EAASE,GAATF,GAAgB7O,MACdC,EAAO+M,GAAWhN,CAAXgN,CAAP/M,EAAuB,oCAAvBA,GACA+O,EAAO1N,KAAP0N,CAAapB,OAAboB,GAAuBhP,CADvBC,EAEO4O,CAHO7O,CAFhB0N,EAOAmB,EAASE,GAATF,CAAaI,UAAbJ,GAA0B,MAAMG,EAAO1N,KAAP0N,CAAapB,OAP7CF;AAO6CE,MACvCsB,IAAUL,EAASM,OAATN,GAAmBlE,GAAiB,SAAjBA,CADUiD;AAAAA,MAEvCwB,IAAQP,EAASO,IAATP,GAAiBK,EAAepF,SAAfoF,CAAyB;AACtDG,WAAO,MAD+C;;AAEtDrP,cAAoBmC;AAAAA,UAApBnC;AAAGsP,gBAACA,CAAJtP;AAAGqD,gBAASA,CAAZrD;AAAGmC,gBAAiBA;AAApBnC,OAAoBmC;AAAAA,UACH,WAAXmN,CADcnN,EACK,OAAO;AAACkB,iBAAD;AAASlB;AAAT,OAAP;AAAgBA;;AAHa,GAAzB+M,CAFctB;AAAAA,MAQvC/I,IAAQgK,EAAShK,IAATgK,GAAiBK,EAAepF,SAAfoF,CAAyB;AACtDG,WAAO,MAD+C;;AAEtDrP,cAAoBuP;AAAAA,UAApBvP;AAAGsP,gBAACA,CAAJtP;AAAGqD,gBAASA,CAAZrD;AAAGuP,eAAiBA;AAApBvP,OAAoBuP;AAAAA,UACH,WAAXD,CADcC,EACK,OAAO;AAAClM,iBAAD;AAASkM;AAAT,OAAP;AAAgBA;;AAHa,GAAzBL,CARctB;AAAAA,MAcvC4B,IAAYX,EAASW,QAATX,GAAoBO,EAAK3F,GAAL2F,CAAS;AAC7CC,WAAO,UADsC;AAE7CrP,QAAI;AAAA;AAAEmC;AAAF;AAAA,aAAcA,CAAd;AAAA;AAFyC,GAATiN,CAdOxB;AAAAA,MAkBvC6B,IAAYZ,EAASY,QAATZ,GAAoBhK,EAAK4E,GAAL5E,CAAS;AAC7CwK,WAAO,UADsC;AAE7CrP,QAAI;AAAA;AAAEuP;AAAF;AAAA,aAAaA,CAAb;AAAA;AAFyC,GAAT1K,CAlBO+I;AAAAA,MAuBvCoB,IAASjO,EAAW;AACxBO,WAAO;AACLoO,iBAAW/O,GAAQK,CAARL,EAAc,KAAdA,CADN;AAELiN,eACEiB,EAAS3B,aAAT2B,CAAuBjB,OAAvBiB,KAAuBjB,MAChB3N,EAAO,CAAPA,EAAe,sBAAqB4O,EAASc,OAATd,EAASc,EAA7C1P,CADP4O;AAHG,KADiB;AAOxB7N,UAAM,CACJ+I,GACE,CAACoD,CAAD,EAAMyC,CAAN,EAAcpM,CAAd,KAAcA;AAAAA,UACNlC,IAAgDsO,CAD1CpM;AAAAA,UAERoK,IAAUtM,EAAMsM,OAFRpK;;AAEQoK,UAChBnK,GAAYD,CAAZC,CADgBmK,EACI;AAAA,YAChBiC,IAAWpM,GAAYD,CAAZC,EAAoBmF,QAApBnF,CAA6BnC,EAAMoO,SAAnCjM,CADK;AAElBoM,cAAUjC,IAAUiC,CAApBA;AAAoBA;;AAAAA,aAE1B1C,EAAIS,OAAJT,GAAcS,CAAdT,EACOA,CAHmB0C;AAGnB1C,KATXpD,EAWE,CAXFA,EAYE,CAZFA,CADI,EAeJA,GACE,QAA0CqD,CAA1C,EAA6C5J,CAA7C,KAA6CA;AAAAA,UAA7C;AAAEH,iBAAF;AAAUiL,cAAV;AAAeV,kBAAf;AAAwB5F,kBAAO,CAAC3E,CAAD;AAA/B,OAA6CG;AAAAA,UACrCsM,IAAYC,GAAU1M,CAAV0M,EAAkBzB,CAAlByB,EAAuB,CAAvBA,EAA6Bb,CAA7Ba,EAAqCvM,CAArCuM,CADyBvM;AAAAA,UAErCwM,IAAWD,GAAU1M,CAAV0M,EAAkBzB,CAAlByB,EAAuB,CAAvBA,EAA8Bb,CAA9Ba,EAAsCvM,CAAtCuM,CAF0BvM;AAAAA,UAEYA,CAChDyM,CADgDzM,EAC5CrB,CAD4CqB,IAClC0M,GAAMtC,CAANsC,EAAeF,CAAfE,EAAyBlI,CAAzBkI,CAHsB1M;AAIvCyM,YACExH,GAAStG,CAATsG,KAAoBuE,GAAW7K,EAAOgO,IAAlBnD,CAApBvE,GACFtG,EAAOgO,IAAPhO,CAAY2N,CAAZ3N,EAAuB6N,CAAvB7N,CADEsG,GAGFqH,EAAU3N,CAAV2N,CAJAG;AAIU9N,KATlB4H,EAaE,CAbFA,EAcE,CAdFA,CAfI,CAPkB;AAuCxBxI,UAAM;AAAC6O,UAAI,IAAL;AAAWC,UAAI;AAAf;AAvCkB,GAAXtP,CAvB8B6M;AAgE7C5M,IAAKM,KAALN,CAAWgO,MAAXhO,GAAoBgO,CAApBhO,EACAkB,EACElB,EAAKgB,GADPE,EAEE6H,GACE,CAAC1G,CAAD,SAAmBG,CAAnB,KAAmBA;AAAAA,QAAlBH;AAAS2L;AAAT3L,KAAkBG;AAAAA,QACX2J,IAAMrM,GAAU0C,CAAV1C,IACR;AAACuC,eAAD;AAASiL,WAAK;AAACE,WAAGhJ,CAAHgJ,EAAGhJ,EAAJ;;AAAciJ,WAAGjJ,CAAHiJ,EAAGjJ;;AAAjB;AAAd,KADQ1E,GAGRuC,CAJaG;AAIbH,WACJR,EAAO;AACLzB,cAAQ4N,CADH;AAEL3L,cAAQ8J,CAFH;AAGL7J,aAAO,CAHF;AAILhC,aAAOmC,GAAYD,CAAZC;AAJF,KAAPZ,GAMOsK,EAAI9J,MAPPA;AAOOA,GAZf0G,EAcE,CAdFA,EAeE,CAfFA,CAFF7H,CADAlB,EAsBA6N,EAASzF,MAATyF,GAAmBxL;AAAAA,QACXiL,IAAMD,GADKhL;AAAAA,QAEXP,IAAU;AAACO,eAAD;AAASiL;AAAT,KAFCjL;;AAEQiL,QACrBlL,EADqBkL,EACX;AAAA,WACPjK,EADO,EACE;AAAA,YACNiM,IAAYlN,EADN;AAEZkL,UAAIA,GAAJA,CACGa,OADHb,CACW;AACPiC,aAAYD,CAAZC;AAAYD,SAFhBhC,EAIGI,KAJHJ,CAIS,QAJTA;AAMFzL;;AAAAA,QAAO;AAACzB,gBAAQyN,CAAT;AAAmBxL,gBAAQP,CAA3B;AAAoCxB,eAAO8B;AAA3C,OAAPP;AAAkDO,KAV3BkL,MAYvBzL,EAAOgM,CAAPhM,EAAiBC,CAAjBD;;AAAiBC,WAEZwL,EAAIA,GAFQxL;AAERwL,GAtCbtN;AAsCasN,MAGPkC,IAAY3B,EAAS2B,QAAT3B,GAAoBxE,EAAY,CAAZA,EAAe;AAACgF,WAAO;AAAR,GAAfhF,EACnCkB,EADmClB,CAChCwE,CADgCxE,EACtBoG,KAAKA,IAAI,CADapG,EAEnCkB,EAFmClB,CAEhC6E,CAFgC7E,EAExBoG,KAAKA,IAAI,CAFepG,CAHzBiE;AAMbZ,KAAQwB,CAARxB,EAAgB,eAAhBA,EAAiC,KAAjCA,GACAA,GAAQmB,CAARnB,EAAkB,eAAlBA,EAAmC,CAAnCA,CADAA;AACmC,MAC7BgD,IAAW7B,EAAS6B,OAAT7B,GAAmB2B,EAAS/G,GAAT+G,CAAa;AAE/CxQ,QAAI2Q,KAAUA,IAAS,CAFwB;AAG/CtB,WAAO;AAHwC,GAAbmB,CADD;AAI1B,SAGT7N,GAAIkM,CAAJlM,EAAc,CAACuM,CAAD,EAASE,CAAT,EAAevK,CAAf,EAAqB2K,CAArB,EAA+BC,CAA/B,EAAyCiB,CAAzC,EAAkDF,CAAlD,CAAd7N,GACOkM,CAJE;AC5HJ;;AAAA,SAAS+B,CAAT,CAAgBxE,CAAhB,EAAgBA;AAAAA,MACjByE,CADiBzE;AACjByE,GACFzE,CADEyE,EACMA,CADNA,IACkB9I,EAAoBqE,CAApBrE,EAA4B,CAA5BA,CADlB8I;AAC8C;AAC9C3P,YAACA,CAD6C;AAC7CA,YAAQ4P,CADqC;AAC9CC,eAAiBA;AAD6B,MAChB3E,CADgB;AAAA,MAE5C4E,IAAWpC,EAAaxC,CAAbwC,EAAqBiC,CAArBjC,CAFiC;AAGlDlB,KAAQsD,CAARtD,EAAkB,UAAlBA,EAA8B,CAA9BA;AAA8B,MAE1BuD,CAF0B;AAAA,MAE1BA;AADEjC,YAACA;AACHiC,MADalN,EAASiN,CAATjN,EAAmBzC,KADN;AAAA,MAGxB4P,IAAenH,GACnB,CAACoD,CAAD,EAAMC,CAAN,EAAS5J,CAAT,KAASA;AAAAA,QAOH2N,CAPG3N;AAAAA,QAOH2N;AANE9N,cAACA,CAMH8N;AANE7C,WAASA,CAMX6C;AANEvD,eAAcA;AAMhBuD,QAN2BhE,CADxB3J;AAAAA,QAED0L,IAAS8B,EAAS7B,OAFjB3L;AAAAA,QAGDiL,IAAKsB,GAAU1M,CAAV0M,EAAkBzB,CAAlByB,EAAuB,CAAvBA,EAA8Bb,CAA9Ba,EAAsCvM,CAAtCuM,CAHJvM;AAAAA,QAID4N,IAAa5N,EAAM+J,CAJlB/J;AAAAA,QAKD6N,IAAkBnK,EAAU0G,CAAV1G,CALjB1D;AAAAA,QAMHyM,IAAK,CANFzM;;AAME,QAELuN,KACAd,CADAc,EACII,CADJJ,IACsBb,GAAMa,CAANb,EAAiBzB,CAAjByB,EAAqB,CAAC7M,CAAD,EAAS+N,CAAT,CAArBlB,CADtBa,GAGFI,IAAiBjQ,KAAUmQ,CAAVnQ,GAA4BkQ,CAA5BlQ,GAAyCmC,CAHxD0N,EAKAd,CAPK,EAOD;AAAA,WACFoB,CADE,EACFA,OAWFlE,EAAInF,IAAJmF,GAAW,CAACiE,CAAD,EAAaD,CAAb,CAAXhE,EACO,CAZLkE;AACFxO,QAAO;AACLzB,gBAAQwM,CADH;AAELvK,gBAAQ;AACNA,kBAAQ8N,CADF;AAEN7C,eAAK;AAACE,gBAAIuB,GAAU1M,CAAV0M,EAAkBzB,CAAlByB,EAAuB,CAAvBA,EAA6Bb,CAA7Ba,EAAqCvM,CAArCuM,CAAL;AAAkDtB;AAAlD;AAFC,SAFH;AAMLlL,cAAMC,EAAMD,IANP;AAOLD,eAAO;AAPF,OAAPT;AAOS;AAAA,GAvBIkH,EA+BnB,CA/BmBA,EAgCnB,CAhCmBA,CAHS;;AAmC5B,MAEE7I,CAFF,EAEU;AAAA,QACNkK,CADM;AAENlE,MAAShG,CAATgG,KACFkE,IAAQlK,CAARkK,EACAzI,GAAIyI,CAAJzI,EAAW,CAACqO,CAAD,CAAXrO,CAFEuE,KAIFkE,IAAQuC,EAAQzM,CAARyM,CAARvC,EACAzI,GAAIqO,CAAJrO,EAAc,CAACyI,CAAD,CAAdzI,CALEuE,GAOJ+J,IAAc,CAAC3D,GAAKV,EAAcxB,CAAdwB,CAALU,CAAD,EAA6B4D,CAA7B,CAPVhK;AAOuCgK,GAX3C,MAaAD,IAAc,CAACC,CAAD,CAAdD;;AAEFjC,IAAOhN,GAAPgN,CAAWsC,MAAXtC,CAAkB,CAAlBA,EAAqB,CAArBA,EAAqB,GAAMiC,CAA3BjC,GACAgC,EAASjC,GAATiC,CAAaF,CAAbE,CADAhC;AACa8B,MACPS,IAA8BzQ,GAAUgQ,CAAVhQ,CADvBgQ;AACiCA,SAC1CS,MACF9J,OAAOC,MAAPD,CACEN,GAAiB6J,CAAjB7J,CADFM,EAEEE,EAAWqJ,EAASxJ,SAApBG,EAA+B4J,CAA/B5J,CAFFF,GAKAuJ,EAAS9D,aAAT8D,CAAuBxQ,MAAvBwQ,GAAgCO,CAN9BA,GAQJnH,GAAgB0G,CAAhB1G,EAAwB4G,CAAxB5G,ETnFoB,QSmFpBA,CARImH,EASGP,CAVuCF;ACtEzC;;AAAA,SAASU,CAAT,GAAsBxJ;AAAAA;AAAAA;AAAAA;;AAAAA,QACrBtC,CADqBsC,EACdyJ,CADczJ,GACJI,CADIJ,IACQD,EAAoBC,CAApBD,CADRC;AAAAA,MAErB7F,IAAqC,EAFhB6F;AAEgB,SAC3CtI,EAAM+R,CAAN/R,EAAe,CAACM,CAAD,EAAKH,CAAL,KAAKA;AAAAA,QACZmJ,IAAS7G,EAAOtC,CAAPsC,IAAc0G,EAAYhJ,CAAZgJ,EAAiB;AAC5CrI,cAAQM,GAAU4E,CAAV5E,CADoC;AAE5CsL,cAAQhE;AAFoC,KAAjBS,CADXhJ;AAKlB6F,MAAM6F,EAAN7F,CAASsD,CAATtD,EAAgB1F,CAAhB0F,GACA0E,GAAgB1E,CAAhB0E,EAAuBpB,CAAvBoB,CADA1E;AACuBsD,GANzBtJ,GAQOyC,CAToC;ACUtC;;AAAA,SAASuP,CAAT,CAAsB5I,CAAtB,EAAoCC,CAApC,EAAoCA;AAAAA,MACnC/H,IAAOD,EAAW;AAACS,YAAQ;AAACE,YXhBd;AWgBa,KAAT;AAAyBC,cAAU;AAAnC,GAAXZ,CAD4BgI;AAAAA,MAGnC5G,IAAS;AACbwP,aAAS,EADI;AAEbtI,cAAUrI,CAFG;AAGb4Q,WAAO;AAHM,GAH0B7I;AASzC/H,IAAKO,IAALP,GAAYsI,GXxBQ,QWwBRA,EAAiBnH,CAAjBmH,EAAyBR,CAAzBQ,EAAuCP,CAAvCO,CAAZtI,EAEAtB,EACE;AACEmS,WAAOhJ,CADT;AAEEiJ,YAAQlD,CAFV;AAGEmD,WAAO1H,CAHT;AAIE2H,YAAQN;AAJV,GADFhS,EAOE,CAACuS,CAAD,EAAUC,CAAV,KAAUA;AAAAA,QACFC,IAAeD,EAAIE,WAAJF,EADbA;AAAAA,QAGFxG,IAAUf,GAAkB,KAAIuH,GAAtBvH,CAHRuH;AAIR/P,MAAOyP,KAAPzP,CAAagQ,CAAbhQ,IAA6BuJ,CAA7BvJ;AAA6BuJ,QAEvB2G,IAAM,IAAIC,GAAJ,EAFiB5G;AAG7BvJ,MAAOwP,OAAPxP,CAAgB,GAAEgQ,IAAlBhQ,IAAqCkQ,CAArClQ,EAEAuJ,EAAQtC,MAARsC,GAAiB6G,MACf1P,EAAO6I,CAAP7I,EAAgB0P,CAAhB1P,GACO0P,CAFQA,CAFjBpQ,EAMAD,EACE6B,EAAS2H,CAAT3H,EAAkB/B,GADpBE,EAEE6H,GAAK,CAACoD,CAAD,EAAMC,CAAN,EAAS5J,CAAT,MACHA,EAAMlC,KAANkC,GAAc,IAAdA,EACO2J,CAFJ,CAALpD,CAFF7H,CANAC,EAaAuJ,EAAQnC,KAARmC,CAAclG;AACZ7C,SAAIR,CAAJQ,EAAY,CAAC6C,CAAD,CAAZ7C,GACA0P,EAAInQ,GAAJmQ,CAAQ7M,CAAR6M,CADA1P,EAEK6C,EAAKgN,QAALhN,KAAeA,EAAKgN,QAALhN,GAAgB6M,CAA/B7M,CAFL7C,EAGK7B,GAAU0E,CAAV1E,MAAiB0E,EAAKhF,MAALgF,GAAcrD,CAA/BrB,CAHL6B;AAGoCR,KAJtCuJ,CAbAvJ,EAmBAQ,GAAIR,CAAJQ,EAAY,CAAC+I,CAAD,CAAZ/I,CAnBAR,EAqBAA,EAAQ,WAAU+P,GAAlB/P,IAA4BsQ,MAC1B3S,EAAQuS,CAARvS,EAAa2S,CAAb3S,GACO4L,EAAQnC,KAARmC,CAAc+G,CAAd/G,CAFmB+G,CArB5BtQ,EAyBAA,EAAQ,SAAQ+P,GAAhB/P,IAAyBA,EAAOgQ,CAAPhQ,IAAuB,CAC9C2G,CAD8C,EAE9CsD,CAF8C,KAG3CV,EAAQuG,EAAQnJ,CAARmJ,EAAsB;AAACzR,cAAQ2B,CAAT;AAAiBkG,UAAI+D;AAArB,KAAtB6F,CAARvG,CA5BLvJ;AA4BwDiK,GA1C5D1M,CAFAsB;AA4C4DoL,MAItD5L,IAASM,GAAUqB,CAAVrB,CAJ6CsL;AAInCjK,SACrB3B,KACFd,EAAMyC,EAAOyP,KAAblS,EAAoB,CAACuB,CAAD,EAAiBpB,CAAjB,KAClBsK,GAAelJ,CAAfkJ,EAAqB3J,EAAOoR,KAAPpR,CAAaX,CAAbW,CAArB2J,CADFzK,CADEc,EAKG2B,CANkBA;ACpEpB;;AAAA,SAASuQ,CAAT,CAA2BC,CAA3B,EAA2BA;AAChCxK,KAAawK,CAAbxK;AAAawK,MACPC,IACJC,KAAoBF,CAApBE,GAAiCF,EAAWE,CAAXF,GAAjCE,GAAkEF,CAFvDA;AAGb1S,IAAO2S,EAAeE,SAAtB7S,EAAiC,sCAAjCA;AAAiC,MAC3B+I,IAAQH,GADmB;AAAA,MAE3BkK,IAAWjH,GAAmB9C,CAAnB8C,CAFgB;AAEG9C,SACpC4J,EAAeE,SAAfF,CAAyB;AACvBtQ,UAAM0G,CADiB;AAEvBuG,WAAOwD,CAFgB;AAGvBC,cAAUD;AAHa,GAAzBH,GAKO5J,CAN6BA;ACP/B;;AAAA,SAASiK,CAAT,CACL3H,CADK,EAELc,CAFK,EAELA;AAEAX,KAAcH,CAAdG,EAAqB,OAArBA,EAA8B,gBAA9BA;AAA8B,MACxBtJ,IAAS0G,EAAY;AACzB7B,UAAMH,EAAeyE,CAAfzE,EAAsB,OAAtBA,CADmB;AAEzB2F,aAAS,CAFgB;AAGzBjE,SAAK6D;AAHoB,GAAZvD,CADe;AAIvBuD,SAEPjC,GAAemB,CAAfnB,EAAsBhI,CAAtBgI,EAA8B,EAA9BA,EAAkC,OAAlCA,GACOhI,CAHAiK;ACkBF;;AAAA,SAAS8G,CAAT,CAA8B9G,CAA9B,EAAsCrF,CAAtC,EAAsCA;AAAAA,MACvCoM,IAAwB,CADepM;AACf,SAC5BjH,EAAQsT,EAARtT,EAA4BuT;AACtBA,SAASjH,CAATiH,KACFpT,EAAwB,QAAjBmM,EAAOiH,CAAPjH,CAAPnM,EAA8BqT,GAAkBvM,CAAlBuM,EAA0BD,CAA1BC,CAA9BrT,GACAkT,IAAwB,CAFtBE;AAEsB,GAH5BvT,GAMOqT,CAPqB;AAUvB;;AAAA,SAASI,CAAT,GAAmBvL;AAAAA;AAAAA;AAAAA;;AAAAA,MACpB5G,CADoB4G;AAAAA,MAEpBhB,CAFoBgB;AAAAA,MAIpByF,CAJoBzF;AAAAA,MAMpBzB,CANoByB;AAAAA,MAMpBzB,EAHErF,CAGFqF,EAHUiN,CAGVjN,EAHiBvG,CAGjBuG,GAHsB6B,CAGtB7B,IAHkCwB,EAAoBC,CAApBD,CAHdC;AAAAA,MAKpByL,IAAU,CALUzL;AAKV,SAIZgC,GAAOwJ,CAAPxJ,KACAvB,GAASvH,CAATuH,CADAuB,IAEAkJ,EAAqBhS,CAArBgS,Ed3CkB,Qc2ClBA,CAFAlJ,KAIAwJ,IAAQtS,EAAOsS,KAAfA,EACAxT,IAAKkB,EAAOlB,EADZwT,EAEAC,KAAWvS,EAAOwS,MAFlBF,EAGAjN,IAASrF,EAAOqF,MAHhBiN,EAKApS,IAASF,EAAOE,MALhBoS,EAMAxM,IAAO9F,EAAO8F,IANdwM,EAOA/F,IAAMvM,EAAOuM,GAPb+F,EAQAtS,IAASA,EAAOA,MAZhB8I,GAcK2J,GdvDa,QcuDbA,EAELH,CAFKG,EAGLzS,CAHKyS,EAILpN,CAJKoN,EAKLvS,CALKuS,EAML3T,CANK2T,EAOL3M,CAPK2M,EAQLvL,CARKuL,EASLF,CATKE,EAUL,CAVKA,EAWL,CAXKA,EAYLlG,CAZKkG,CAlBO;AC7CT;;AAAA,SAASC,CAAT,GAAkB5L;AAAAA;AAAAA;AAAAA;;AAAAA,QACjB9G,CADiB8G,EACToE,CADSpE,GACAI,CADAJ,IACYD,EAAoBC,CAApBD,CADZC;AACgCA,SAClDoE,MACHA,IAASlL,CAATkL,EACAlL,IAASkL,EAAOlL,MAFbkL,GAIL8G,EAAqB9G,CAArB8G,EAA6B,OAA7BA,CAJK9G,EAKEuH,GACL,OADKA,EAELvH,EAAOoH,KAFFG,EAGLzS,CAHKyS,EAILvH,EAAO7F,MAJFoN,EAKLvH,EAAOhL,MALFuS,EAML,IANKA,EAOLvH,EAAOpF,IAPF2M,EAQLvL,CARKuL,EAQLvL,CACCgE,EAAOsH,MATHC,EAUL,CAVKA,EAWL,CAXKA,CANgD3L;ACGlD;;AAAA,SAAS6L,CAAT,CAAiBlU,CAAjB,EAAsB2K,CAAtB,EAAoC8B,CAApC,EAAoCA;AAAAA,MACrClF,EAASvH,CAATuH,CADqCkF,EAC5BzM,OACXsJ,EAAU,CAAVA,EAAiB,iBAAjBA,GACOtJ,CAFIA;;AAEJA,MAELuH,EAASvH,CAATuH,KAAiBA,EAAUvH,CAAVuH,CAFZvH,EAE4B;AAAA,QAC7BmU,IAAShT,GAAUnB,CAAVmB,CADoB;AAAA,QAE7BqB,IAASkI,EAAYC,CAAZD,EAA0B;AACvC7J,cAAQsT,CAD+B;AAEvC9M,YAAMrH,EAAI6H,SAF6B;AAGvCe,WAAK6D;AAHkC,KAA1B/B,CAFoB;AAK5B+B,WAEPjC,GAAejD,EAAUvH,CAAVuH,IAAiBvH,EAAI6P,QAArBtI,GAAgCvH,CAA/CwK,EAAoDhI,CAApDgI,GACI2J,KAAQA,EAAOlC,KAAPkC,CAAapO,KAAboO,CAAmB3R,CAAnB2R,CADZ3J,EAEOhI,CAJAiK;AAIAjK;;AAAAA,MAEHA,IAA8BuB,MAAMC,OAAND,CAAc/D,CAAd+D,IAAqB,EAArBA,GAA0B,EAFrDvB;AAEqD,SAC9DzC,EACEC,CADFD,EAEE,CAACe,CAAD,EAAQZ,CAAR,KACGsC,EAAOtC,CAAPsC,IAAc+E,EAASzG,CAATyG,IAAkBzG,CAAlByG,GAA0BmD,EAAY5J,CAAZ4J,EAAmB;AAACrD,UAAMnH;AAAP,GAAnBwK,CAH7C3K,GAKOyC,CANuD;ACUzD;;AAAA,SAAS4R,CAAT,GAAkB/L;AAAAA;AAAAA;AAAAA;;AAAAA,MAEnBgM,CAFmBhM;AAAAA,MAGnBwL,CAHmBxL;AAAAA,MACjBiM,IAAS,OADQjM;AAAAA,MACR,EAGT9G,CAHS,EAGDgT,CAHC,GAGO9L,CAHP,IAGmBL,EAAoBC,CAApBD,CAJXC;AAAAA,MAKjBmM,KAAcD,CALGlM;AAMnBmM,QACFH,IAAU9S,EAAOkT,KAAjBJ,EACAE,IAAQhT,EAAOgT,KADfF,EAEAR,IAAQtS,EAAOsS,KAFfQ,EAGA9S,IAASA,EAAOA,MAJdiT;AAIcjT,MAEZmT,IAAcnN,EAASgN,CAAThN,CAFFhG;AAAAA,MAGZoT,KAAmBpN,EAAQgN,CAARhN,CAAnBoN,IAAqCtH,GAAWkH,CAAXlH,CAHzB9L;AAAAA,MAIZqT,KAAgBF,CAAhBE,IAAgBF,CAAgBC,CAAhCC,IAAmD9L,GAASyL,CAATzL,CAJvCvH;AAKb8S,QAAUA,IAAU,EAApBA,GACAG,IAYHzU,EAAMsU,CAANtU,EAAe,CAAC0B,CAAD,EAASiS,CAAT,KACbmB,GAAaP,CAAbO,EAAqBpT,CAArBoT,EAA8B,SAAQnB,GAAtCmB,CADF9U,CAZGyU,IACHlU,EAAOsU,CAAPtU,EAAqB,2BAArBA,GACAP,EACEwU,CADFxU,EAEE,CAAC0N,CAAD,EAAIvN,CAAJ,KACGmU,EAAQnU,CAARmU,IAAenL,EAAY;AAC1B2D,aAAS,CADiB;AAE1BjE,SAAKH;AAFqB,GAAZS,CAHpBnJ,CADAO,EASA+T,EAAQS,EAART,GAAanL,EAAY;AAAC2D,aAAS,CAAV;AAAgBjE,SAAKH;AAArB,GAAZS,CAVVsL,CADAH;AAW2C5L,MAY5CsM,CAZ4CtM;AAAAA,MAM1CrG,IAAS,IAAIuQ,GAAJ,CACZ,GAAqBxK,MAArB,CAA4B5G,CAA5B,EAAoCsS,KAAS,EAA7C,EAAiD/L,OAAOkN,MAAPlN,CAAcuM,CAAdvM,CAAjD,CADY,CANiCW;AAAAA,MAS1CwM,IAAYnN,OAAOoN,IAAPpN,CAChB4M,KAAeC,CAAfD,GAAiCL,CAAjCK,GAA2CH,CAD3BzM,CAT8BW;AAUH8L,MAGzCG,KAAeC,CAH0BJ,EAIvCG,KAAatS,EAAOG,GAAPH,CAAWmS,CAAXnS,CAAbsS,EACJK,IAAc,CACZL,KAAe/G,GAAKV,EAAcsH,CAAdtH,CAALU,EAA2B,CAA3BA,EAAkC,CAAlCA,CADH,EAEZwH,GAAQ;AACNzO,UAAMgO,CADA;AAEN9N,YAAQ,CAFF;AAGNJ,WAAOkO,CAHD;;AAINrU,OAAGwF,CAAHxF,EAAS+U,CAAT/U,EAAuBwD,CAAvBxD,EAAuBwD;AAAAA,UACf/C,IAAQuU,OAAOX,IAAc7Q,EAAM+J,CAApB8G,GAAwBH,EAAM1O,CAAN0O,CAA/Bc,CADOxR;AAErByR,SACEF,CADFE,EAEEC,EAASN,CAATM,EAAoBzU,CAApByU,IAA6BzU,CAA7ByU,GAAqC,IAFvCD,EAGEzP,CAHFyP,EAIEzR,CAJFyR;AAIEzR;;AAVE,GAARsR,CAFY,CADVT,CAJuCH,KAsBtC,IAAIK,CAAJ,EAAkB;AAAA,QACjBY,IAAa1K,GAAe,EAAfA,CADI;AAEvB0K,MAAWzT,IAAXyT,GAAkB,OAAlBA;AAAkB,QAEdC,CAFc;AAAA,QACZ9J,IAAQ,EADI;AAGlB5L,MAAMwU,CAANxU,EAAa,CAAC2V,CAAD,EAAYxV,CAAZ,KAAYA;AAAAA,UACnBqH,EAAQmO,CAARnO,CADmBrH,EACC;AACtBuV,YAAc,CAAdA,EACAlT,EAAIoJ,CAAJpJ,EAAWrC,CAAXqC,CADAkT,EAEArT,EAAOG,GAAPH,CAAWsT,CAAXtT,CAFAqT;AAEWC,YACLC,IAAUnL,GACdkL,CADclL,EAEd,EAFcA,EAGd,CAACmD,GAAK6H,CAAL7H,CAAD,EAAmBvD,GAAK,CAACoD,CAAD,EAAMC,CAAN;AAAA,cAAMA;AAAIG;AAAJH,WAAN;AAAA,iBAAkBG,EAAE1N,CAAF0N,IAASJ,CAA3B;AAAA,SAALpD,CAAnB,CAHcI,CADLkL;;AAI0ClI,YAEjDjG,EAASmO,CAATnO,CAFiDiG,EAE5B;AACvBgI,YAAWjP,OAAXiP,CAAmBtV,CAAnBsV,IAA0BE,EAAUrK,QAAVqK,EAA1BF;AAAoCnK,cAC9BuK,IAAW3I,EAAcyI,CAAdzI,CADmB5B;AAEpC2B,aAASwI,CAATxI,EAAqB;AAAC1L,kBAAMsU,CAAP;AAAiBlC,mBAAOxT,CAAxB;AAA6B6B,kBAAM;AAAnC,WAArBiL,GACAhE,EAAc,iBAAdA,EAAiC4M,CAAjC5M,EAA2C2M,CAA3C3M,CADAgE;AAC2C2I;AAAAA;AAAAA,KAdjD5V,GAkBI0V,KACFzM,EAAc,WAAdA,EAA2BwM,CAA3BxM,CAnBFjJ,EAqBAgV,IAAc,CACZU,KAAgB9H,GAAK6H,CAAL7H,EAAiB,CAAjBA,EAAwB,CAAxBA,CADJ,EAEZ1D,GAAW,CAACpE,CAAD,EAAOuP,CAAP,EAAqBvR,CAArB,KAAqBA;AAAAA,WACzB,IAAII,IAAI,CADiBJ,EACdI,IAAIgR,EAAU/Q,MADAL,EACQI,GADRJ,EACa;AAAA,YACnCgS,IAAWZ,EAAUhR,CAAVgR,CADwB;AACdhR,YACTsR,EAAS5J,CAAT4J,EAAgBM,CAAhBN,IACd1R,EAAM+J,CAAN/J,CAAQgS,CAARhS,CADc0R,GAEdhB,EAAMsB,CAANtB,EAAgB1O,CAAhB0O,CAHuBtQ,EAGP4B,YAElByP,GAAWF,CAAXE,EAAyBO,CAAzBP,EAAmCzP,CAAnCyP,EAAyCzR,CAAzCyR,CAFkBzP;AAMtByP;;AAAAA,SAAWF,CAAXE,EAAyB,IAAzBA,EAA+BzP,CAA/ByP,EAAqCzR,CAArCyR;AAAqCzR,KAXvCoG,EAYG,CAZHA,CAFY,CArBdlK;AAmCK,GAxCA,MA2CLO,EAAO,CAAPA,EAAc,6CAAdA;AAAc,MAEVwV,IAAe1U,EAAW;AAC9BQ,UAAM;AAAC6O,UAAI6D;AAAL,KADwB;AAE9BzT,YAAQgT,IAAQ,EAARA,GAAatS,CAFS;AAG9BI,WAAO0S,CAHuB;AAI9BhT,UAAM0T,CAJwB;AAK9BlT,YAAQ;AAACO,cAAQ2B,MAAMzC,IAANyC,CAAW3B,CAAX2B;AAAT,KALsB;AAM9B/B,cAAU;AANoB,GAAXZ,CAFL;AAQJ,MAERyS,KACFG,GACEM,CADFN,EAEEH,CAFFG,EAGEzS,CAHFyS,EAIE,IAJFA,EAKE8B,CALF9B,EAME,IANFA,EAOEM,CAPFN,EAQEvL,CARFuL,EAQEvL,CARFuL,EAWE,CAXFA,EAYE,CAZFA,CADEH,EAaA,CAGCW,CAlBO,EAkBK,OAAOH,CAAP;AC1JZ;;AAAA,SAAS0B,CAAT,CACLC,CADK,SAEWC;AAAAA,MADhBD;AACArU,WAACA,CADDqU;AACQtS,YAAQuS;AADhBD,GACgBC;AAAAA,OAEX1O,EAAQyO,CAARzO,CAFW0O,EAGd,OAAOrH,QAAQsH,MAARtH,CAAenO,MAAM,+BAANA,CAAfmO,CAAP;AAA4B,MACxBjL,IAAQ+K,GADgB;AAG9B/K,IAAMwS,UAANxS,GAAmBF,EAAnBE;AAAmBF;AACbsD,aAACA;AADYtD,MACD9B,CADC8B;AAEnBlB,IAAIwE,EAAQpF,KAARoF,CAAcqP,MAAlB7T,EAA0BoB,CAA1BpB;AAA0BoB,MAEpB0S,IAAc,CAACL,CAAD,CAFMrS;AAAAA,MAGpB2S,IAAe,EAHK3S;AAGL,SACrBpB,EACE+T,CADF/T,EAEEgF,EAAUyO,CAAVzO,IACI;AACE7D,YAAQuS,CADV;AAEEtH,SAAK;AACHE,SAAG/N,CAAH+N,EAAG/N;AAED6C,UAAM7C,KAAN6C,GAAc;AAACgM,kBAAQ,MAAT;AAAiB7O;AAAjB,SAAd6C;AAA+B7C,OAH9B;;AAKHgO,SAAGhO,CAAHgO,EAAGhO;AAED6C,UAAM7C,KAAN6C,GAAc;AAACgM,kBAAQ,MAAT;AAAiB7O;AAAjB,SAAd6C;AAA+B7C;;AAP9B;AAFP,GADJyG,GAcI0O,CAhBN1T,GAkBAA,EAAI8T,CAAJ9T,EAAiBwE,CAAjBxE,CAlBAA,EAmBAA,EAAI+T,CAAJ/T,EAAkB,IAAlBA,CAnBAA,EAoBAW,EAAO;AACLzB,YAAQ4U,CADH;AAEL3S,YAAQ4S,CAFH;AAGL3U;AAHK,GAAPuB,CApBAX,EAyBOoB,EAAMgL,GA1BQ;ACXhB;;AAAA,SAAS4H,CAAT,CACLC,CADK,EAELnW,CAFK,EAELA;AAAAA,MAEMD,IAAO,EAFbC;;AAEa,YACFoW,CADE,CACIpV,CADJ,EACIA;AACXkU,MAASnV,CAATmV,EAAelU,CAAfkU,MACJhT,EAAInC,CAAJmC,EAAUlB,CAAVkB,GnBfiB,YmBgBbvB,GAAQK,CAARL,EAAc,IAAdA,CnBhBa,ImBgBoBA,GAAQK,CAARL,EAAc,KAAdA,CnBhBpB,ImBiBfX,EAAGgB,CAAHhB,EAASW,GAAQK,CAARL,EAAc,KAAdA,CAATX,CAFFkC,EAIApC,EAAQkB,EAAKsB,IAAbxC,EAAmBsW,CAAnBtW,CAJAoC,EAKApC,EAAQ0C,EAAUxB,CAAVwB,CAAR1C,EAAyBsW,CAAzBtW,CALAoC,EAMApC,EAAQ4C,EAAS1B,CAAT0B,CAAR5C,EAAwBsW,CAAxBtW,CAPIoV;AAOoBkB,GATb,EAUVD,CAVU;AAaR;;AAAA,SAASE,CAAT,CACL1B,CADK,EAEL2B,CAFK,EAELA;AAAAA,MAEI5S,MAAMC,OAAND,CAAciR,CAAdjR,MAAuBiR,IAAS,IAAI7J,GAAJ,CAAQ6J,CAAR,CAAhCjR,GACAiR,aAAkB7J,GAHtBwL,EAG2B;AAAA,QACnBnU,IAAS,EADU;AACV,WACfrC,EAAQ6U,CAAR7U,EAAgB,CAACW,CAAD,EAAQZ,CAAR,KAAQA;AACtBI,QAAOiH,EAAQrH,CAARqH,CAAPjH,EAAqB,0BAArBA,GACIqW,KAAYA,EAAWzW,CAAXyW,EAAgB7V,CAAhB6V,CADhBrW,EAEAA,EAAOJ,EAAI4N,GAAXxN,EAAgB,wBAAhBA,CAFAA,EAGAA,IAASJ,EAAI4N,GAAJ5N,IAAYsC,CAArBlC,GAA8B,qBAA9BA,CAHAA,EAIAkC,EAAOtC,EAAI4N,GAAXtL,IAAmB1B,CAJnBR;AAImBQ,KALrBX,GAOOqC,CARQ;AAQRA;;AAAAA,SAEFwS,CAFExS;ACjCJ;;AAAA,SAASoU,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,MAGI3C,CAHJ2C;AAAAA,MAEIrK,IAAsCoK,CAF1CC;AAIIvP,IAAUsP,CAAVtP,MACF4M,IAAS0C,CAAT1C,EACA1H,IAASqK,CAFPvP;;AAEOuP,MAGLnV,ICRD,CAAqBhB;AAAAA,QACpBoW,IAAsB3V,EAAW;AACrCO,aAAO;AACLyU,gBAAQ,EADH;AAELvF,kBAAU,CAFL;AAGLmG,cAAM;AAHD,OAD8B;AAMrC3V,YAAM,CACJ+I,GAAK,CAACqD,CAAD,EAAI9L,CAAJ,EAAWkC,CAAX,KAAWA;AACT1C,WAAU0C,CAAV1C,IAImD,UAApDH,GAAQG,GAAU0C,CAAV1C,EAAiBE,IAAzBL,EAA+B,eAA/BA,CAAoD,GACtDW,EAAMkP,QAANlP,IAAkB,CADoC,IAGtDA,EAAMkP,QAANlP,IAAkB,CAAlBA,EACAA,EAAMqV,IAANrV,IAAc,CAJwC,CAJnDR,GACHQ,EAAMqV,IAANrV,IAAc,CADXR;AACW,OAFlBiJ,CADI,EAaJ+K,GAAQ;AAAC7P,kBrBxBQ,SqBwBT;AAAoB2R,eAAO;AAA3B,OAAR9B,CAbI,EAcJ/K,GACE,CAACqD,CAAD,EAAI9L,CAAJ,KAAIA;AAAAA;AACIyU,kBAACA,CADLzU;AACIqV,gBAASA;AADbrV,YACqBA,CADrBA;AAEEA,UAAMkP,QAANlP,GAAiB,CAAjBA,IAAwC,MAAlByU,EAAOlS,MAA7BvC,IACJiN,QAAQsI,OAARtI,GAAkB4B,IAAlB5B,CAAuB;AACjBjN,YAAMqV,IAANrV,KAAeqV,CAAfrV,IACJxB,EAAQiW,EAAOzE,MAAPyE,CAAc,CAAdA,EAAiBA,EAAOlS,MAAxBkS,CAARjW,EAAyCwD;AACvCiN,eAAYjN,EAAMwS,UAAlBvF,GACAjN,EAAMkL,EAANlL,CAASA,EAAM7C,KAAf6C,CADAiN;AACe9P,WAFjBX,CADIwB;AAGab,SAJnB8N,CADIjN;AAKeb,OARvBsJ,EAYE,CAZFA,EAaE,CAbFA,CAdI;AAN+B,KAAXhJ,CADFT;AAAAA,QAuCpBqG,IAAc5F,EAAW;AAC7BC,YAAM,CACJ+I,GAAK,CAACtJ,CAAD,EAAQgU,CAAR,EAAYjR,CAAZ,KAAYA;AAAAA,YACTsT,IAAahW,GAAU0C,CAAV1C,CADJ0C;;AACcA,YACzBsT,KAAchW,GAAUgW,CAAVhW,CADW0C,EACY;AAAA,cACjCuT,IAAYD,EAAW9V,IADU;;AACVA,eAE1BL,GAAQoW,CAARpW,EAAmB,WAAnBA,CAF0BK,IAGmB,cAA9CL,GAAQG,GAAUgW,CAAVhW,EAAsBE,IAA9BL,EAAoC,IAApCA,CAH2BK,EAI3B;AAAA,gBACMoC,IAAWK,GAAYD,CAAZC,CADjB;AAAA,gBAEMrB,IAAK2U,EAAUzV,KAAVyV,CAAgB3L,KAAhB2L,CAAsB3U,EAFjC;AAAA,gBAGMqL,IAAM9M,GAAQoW,CAARpW,EAAmB,KAAnBA,CAHZ;AAIAyC,cAAS4T,QAAT5T,CAAkBqK,CAAlBrK,IAAyBhB,CAAzBgB,EACAA,EAAS6T,YAAT7T,CAAsBqK,CAAtBrK,IAA6B3C,CAD7B2C;AAC6B3C;AAAAA;AAAAA,OAZnCsJ,CADI;AADuB,KAAXhJ,CAvCMT;AAAAA,QA2DpB4W,IAAqB;AACzBC,eAAS7W,CADgB;AAEzB6D,WAvBW,EAqBc;AAGzB8S,oBAAc,EAHW;AAIzBD,gBAAU,EAJe;;AAKzBhM,eAAStF,CAATsF,EAAStF;AAAAA,YACH,aAAaA,CADVA,EACUA,OACRO,GAAWhD,EAAXgD,EAAwBiR,CAAxBjR,EAAqC,IAArCA,EAA2CP,CAA3CO,EAAkDC,OAD1CR;AAC0CQ,YAErDlF,IAAO+C,EAAS2B,CAAT3B,CAF8CmC;AAErCR,eACfO,GAAWhD,EAAXgD,EAAwBiR,CAAxBjR,EAAqCjF,CAArCiF,EAA2CjF,EAAKM,KAALN,CAAWoK,KAAtDnF,EAA6D,CAA7DA,EACJC,OAFmBR;AAEnBQ,OAXoB;;AAazB4I,YrB7EiB,OqBgEQ;AAczBzF,gBAAUtI,EAAW;AACnBS,gBAAQ;AACNE,gBrBjFc,QqBgFR;AAENI,iBAAO,CAAC4U,CAAD,EAAsB/P,CAAtB;AAFD,SADW;AAKnBpF,cAAM;AAACjB,gBAAM;AAAP,SALa;AAMnBgB,eAAO;AAACoV;AAAD;AANY,OAAX3V,CAde;AAsBzB6F,uBAAiB,EAtBQ;AAuBzBgC,gBAAU,EAvBe;AAwBzBlC,eAASgQ,CAxBgB;AAyBzB/P;AAzByB,KA3DDrG;AAoFxBqG,WAEKuQ,CAFLvQ;AAEKuQ,GAtFF,EDQqBpD,CCRrB,CDKM2C;;AAGe3C,MAEtB1H,CAFsB0H,EAEd;AAAA,QACN1H,EAAOuI,MADD,EACS;AAAA,UACXyC,IAAef,EAAgBjK,EAAOuI,MAAvB0B,EAA+B/V,KAClDL,EAAOiH,EAAS5G,CAAT4G,CAAPjH,EAAuB,4CAAvBA,CADmBoW,CADJ;AAIjB5O,aAAOC,MAAPD,CAAcnG,EAAM2V,YAApBxP,EAAkC2P,CAAlC3P;AAEE2E;;AAAAA,MAAOxD,QAAPwD,KACF9K,EAAMsH,QAANtH,GAAiB+U,EAAgBjK,EAAOxD,QAAvByN,EAAiC/V,KAChDL,EACEiH,EAAU5G,CAAV4G,CADFjH,EAEG,+CAFHA,CADeoW,CADfjK;AAIG;;AAAA,SAKF9K,CALE;AEZJ;;AAAA,SAAS+V,CAAT,CAAiBvD,CAAjB,UAA0Ca;AAAAA,MAAzBb;AAAwBa,YAACA;AAAzBb,GAAyBa;AAC/C1U,IAAOwI,GAASkM,CAATlM,CAAPxI,EAAyB,qCAAzBA;AAAyB,MAKrBmD,CALqB;AAAA,MAMrBkU,CANqB;AAAA,MAOrBC,CAPqB;AAAA,MACnBC,IAAmBnB,EAAgB1B,CAAhB0B,CADA;AAAA,MAEnBoB,IAAgBhQ,OAAOiQ,mBAAPjQ,CAA2B+P,CAA3B/P,CAFG;AAAA,MAGnBkQ,IAAqB,EAHF;AAAA,MAInBC,IAAc,EAJK;AAQrB1Q,IAAS4M,CAAT5M,KACF9D,IAAW0Q,CAAX1Q,EACAmU,IAAe,CADfnU,EAEAnD,EAAOmD,EAAS+T,OAAhBlX,EAAyB,qCAAzBA,CAFAmD,EAGAkU,IAAiBvT,EAASX,EAAS+T,OAAlBpT,CAJfmD,IAKOA,EAAU4M,CAAV5M,IACToQ,IAAiBvT,EAAS+P,CAAT/P,CADRmD,GAGTjH,EAAO,CAAPA,EAAc,qDAAdA,CAREiH,EAUJgP,EAAeoB,CAAfpB,EAAgC,CAAClV,CAAD,EAAOyM,CAAP,KAAOA;AAEjCyH,MAASuC,CAATvC,EAAwBzH,CAAxByH,MACFhT,EAAIyV,CAAJzV,EAAgBlB,CAAhBkB,GACAA,EAAI0V,CAAJ1V,EAAiBsV,EAAiB/J,CAAjB+J,CAAjBtV,CAFEgT;AAEgCzH,GAJtCyI,CAVIhP,EAiBJrE,EAAO;AACLzB,YAAQuW,CADH;AAELtU,YAAQuU,CAFH;AAGLtW,WAAO8B;AAHF,GAAPP,CAjBIqE,EAsBAqQ,KACF9P,OAAOC,MAAPD,CAAcrE,EAAU6T,YAAxBxP,EAAsC+P,CAAtC/P,CAvBEP;ACpBC;;AAAA,SAAS2Q,CAAT,CAAmBvX,CAAnB,EAAoD;AAAA,MAAjCA;AAAMgB,WAACA;AAAPhB,GAAiC;AACzDL,IACEqB,KAAS8B,EADXnD,EAEE,qDAFFA;AAEE,MAEI6X,IAAgBxW,KAAS8B,EAF7B;AAE6BA,SACxB8D,EAAU5G,CAAV4G,IACH7D;AAAAA,QACQiL,IAAMD,GADdhL;AACcgL,WACZxL,EAAO;AACLzB,cAAQd,CADH;AAEL+C,cAAQ;AACNA,iBADM;AAENiL;AAFM,OAFH;AAMLhN,aAAOwW;AANF,KAAPjV,GAQOyL,EAAIA,GATCD;AASDC,GAXVpH,GAaH7D,MACER,EAAO;AAACzB,YAAQd,CAAT;AAAe+C,aAAf;AAAuB/B,WAAOwW;AAA9B,GAAPjV,GACOQ,CAFTA,CAd2BD;ACH1B;;AAAA,SAAS2U,CAAT,CACLzW,CADK,EAEyD;AAAA,MAA9D8K,CAA8D;AAAA,MAExD4L,IAAgB5L,EAAO6L,MAAP7L,GAAgBA,EAAO6L,MAAP7L,CAAc3C,GAAd2C,CAAkB;AAAA;AAAEqB;AAAF;AAAA,WAAWA,CAAX;AAAA,GAAlBrB,CAAhBA,GAAoD,EAFZ;AAAA,MAGxDjK,IAAS,EAH+C;AAG/C,SACfzC,EAAM4B,EAAM2V,YAAZvX,EAA0B,CAACe,CAAD,EAAQgN,CAAR,KAAQA;AAAAA,QAC5ByH,EAAS8C,CAAT9C,EAAwBzH,CAAxByH,CAD4BzH,EACE;AAAA,QAC5BrL,IAAKd,EAAM0V,QAAN1V,CAAemM,CAAfnM,CADuB;AAIhCa,MAAOsL,CAAPtL,IADEC,KAAMA,KAAMd,EAAM6C,GAAlB/B,GACYd,EAAM6C,GAAN7C,CAAUc,CAAVd,EAAc4E,OAD1B9D,GAGY3B,CAFd0B;AAEc1B,GAPlBf,GAUI,iBAAiB0M,CAAjB,IAAiBA,CAAWA,EAAO8L,WAAnC,KACFjY,EAAOqB,EAAM6V,OAAblX,EAAsB,qCAAtBA,GACAiW,EAAenS,EAASzC,EAAM6V,OAAfpT,CAAfmS,EAAwC,CAAClV,CAAD,EAAOyM,CAAP,KAAOA;AAEzCA,SAAOtL,CAAPsL,IACDyH,EAAS8C,CAAT9C,EAAwBzH,CAAxByH,CADCzH,IAED9M,GAAQK,CAARL,EAAc,WAAdA,CAFC8M,IAG6B,aAA/B9M,GAAQK,CAARL,EAAc,WAAdA,CAHE8M,KAKFtL,EAAOsL,CAAPtL,IAAcb,EAAM0J,QAAN1J,CAAeN,CAAfM,CALZmM;AAK2BzM,GAPjCkV,CAFE,CAVJxW,EAsBOyC,CAvBQ;ACdV;;AAAA,IAAM0Q,IACQ,sBAAXsF,MAAW,IAAeA,OAAOxF,UAAtB,IAAqC,cADnD;AAAA,IzBOMhJ,IAAM,KyBPZ;AAAA,IzBQMlE,IAAQ,OyBRd;AAAA,ICKMnF,IAAOX,MAAQqN,GAAWrN,CAAXqN,KAAmBvE,GAAS9I,CAAT8I,CAA3B9I,KAA6C,UAAUA,CDLpE;;ACOP,MAAMuH,IAAMxF,KAAe/B,KAAOW,EAAKX,CAALW,KAAaX,EAAImP,IAAJnP,KAAa+B,CAA5D;;AAEO,IAAMgE,IAAQwB,E1BTA,O0BSAA,CAAd;AAAA,IACM8B,IAAQ9B,E1BTA,O0BSAA,CADd;AAAA,IAEM4J,IAAS5J,E1BTA,Q0BSAA,CAFf;AAAA,IAKM4M,IAAS5M,E1BXA,Q0BWAA,CALf;AAAA,IAMM5F,IAAQ4F,E1BXA,O0BWAA,CANd;A1BLc;AAAAkR;AAAA9X;AAAAoF;AAAAsD;AAAA8H;AAAAgD;AAAAxS;AAAA;;AJKd,IAAM4T,IAAW,CAAInV,CAAJ,EAAekC,CAAf,KAA2BlC,EAAKmV,QAALnV,CAAckC,CAAdlC,CAA5C;AAAA,IAEMsY,IAAa,CAAItY,CAAJ,EAAekC,CAAf,KAAeA;AAAAA,MACjCqW,IAAMvY,EAAKwY,OAALxY,CAAakC,CAAblC,CAD2BkC;AACdA,GACZ,CADYA,KACrBqW,CADqBrW,IAEvBlC,EAAKuR,MAALvR,CAAYuY,CAAZvY,EAAiB,CAAjBA,CAFuBkC;AAEN,CALd;AAAA,IASMC,IAAM,CAAInC,CAAJ,EAAekC,CAAf,KAA2BlC,EAAKyY,IAALzY,CAAUkC,CAAVlC,CATvC;AAAA,ICLMkJ,IAAY,CACvB/I,CADuB,EAEvBuY,CAFuB,EAGvBC,CAHuB,KAGvBA,CAECxY,CAFDwY,IAGAC,QAAQpJ,KAARoJ,CACG,GAAEF,kBACDC,IAAc,SAAQA,WAAtBA,GAA6C,IAFjDC,CDDK;AAAA,I+BNM5U,IAAY6U,KACtBA,EAA2BvP,QAA3BuP,IAAuCA,C/BKnC;AAAA,I+BJMpW,IAAaxB,KAAeA,EAAKQ,MAALR,CAAYe,M/BI9C;AAAA,I+BHMW,IAAY1B,KAAeA,EAAKQ,MAALR,CAAYc,K/BG7C;AAAA,I+BFM8K,IAAiBlH,KAAgCA,EAAMqF,Q/BE7D;AAAA,I+BDMnI,IAAWY,KAASA,EAAM/C,K/BChC;AAAA,I+BAMmL,KAAkBlG,KAAsBA,EAAMmF,W/BApD;AAAA,I+BCM/J,KAAYR,KAAQA,EAAKE,M/BD/B;AAAA,I+BEMiD,KAAeoV,KAAsBA,EAAIvX,K/BF/C;AAAA,I+BGMX,KAAU,CAACL,CAAD,EAAiB+S,CAAjB,KACrBtP,EAASzD,CAATyD,EAAexC,IAAfwC,CAAoBsP,CAApBtP,C/BJK;AAAA,I+BKM2J,KAAU,CAACpN,CAAD,EAAiB+S,CAAjB,EAAgC5S,CAAhC,KACpBsD,EAASzD,CAATyD,EAAexC,IAAfwC,CAAoBsP,CAApBtP,IAA6BtD,C/BNzB;AAAA,I+BOM0G,KAAoB7G,KAC/BA,EAAKwY,a/BRA;;AgCTP,MAAMC,KAAU;AAAA,MACV3W,IAAK,CADK;AACL,SACF,MAAO,OAAIA,CADT;AACSA,CAFpB;;AAKO,IAAM4W,KAAaD,IAAnB;AAAA,IACME,KAAaF,IADnB;AAAA,IAEM1W,KAAa0W,IAFnB;AAAA,I9BMIxY,KAAkC,I8BNtC;AAAA,I9BQMK,KAAe,MAC1BL,MAAeA,GAAYG,Q8BTtB;AAAA,I9BUMwY,KAAezL,MACtBA,KAAOlN,EAAPkN,IAAsBlN,GAAYM,OAAlC4M,KACFA,IAAO,GAAElN,GAAYM,WAAW4M,GAD9BA,GAEGA,CAHmBA,C8BVrB;AAAA,I9B8BM0L,KAAc;AAAA;AACzB1L,UADyB;AAEzBzG,WAFyB;AAGzBoS,UAHyB;AAIzBrS,aAJyB;AAKzB/G;AALyB;AAAA,SAgBlBK,EAHSU,EAAW;AACzBQ,UAAM;AAACV,eAASqY,GAAYzL,CAAZyL,CAAV;AAA4BlS,aAA5B;AAAkCoS,YAAlC;AAAuCrS;AAAvC;AADmB,GAAXhG,CAGTV,EAAoBL,CAApBK,CAhBkB;AAAA,C8B9BpB;AAAA,ICAMsC,KAAM,CAAC0W,CAAD,EAAsBvX,CAAtB,KAAsBA;AAAAA,MACjCW,IAAQsB,EAASsV,CAATtV,CADyBjC;AAEvChC,IAAQgC,CAARhC,EAAewZ;AAAAA,QACP/W,IAAOwB,EAASuV,CAATvV,CADAuV;A7BJK,iB6BMd7W,EAAMjB,MAANiB,CAAaf,I7BNC,K6BMgBa,EAAKf,MAALe,CAAYb,IAAZa,G7BHb,WAHH,G6BOlBL,EAAIM,EAAUD,CAAVC,CAAJN,EAAqBO,CAArBP,C7BPkB,E6BQlBA,EAAIQ,EAASD,CAATC,CAAJR,EAAqBK,CAArBL,C7BRkB;A6BQGK,GAJvBzC;AAIuByC,CDNlB;AAAA,I7BGMV,KAAc;AAAA,MACzB9B,CADyB,uEACuB,EADvB;AAAA,SACuB,CACpC2D,MAAMC,OAAND,CAAc3D,CAAd2D,IAAsB3D,CAAtB2D,GAA6B,CAAC3D,CAAD,CADO,EACCwZ,IADD,GACQ9P,GADR,CACY1F,CADZ,CADvB;AAAA,C6BHpB;AAAA,IEEM0E,KAAWhI,KAA0B,mBAAVA,CAAU,IAAsB,SAAVA,CFFvD;AAAA,IEGMuM,KAAavM,KAA0B,qBAAVA,CFHnC;AAAA,IEKMuJ,KAASvJ,UAAmBsF,CAAnBtF,KAASA,CFLxB;AAAA,IEOM0H,KAAe1H,KAC1BR,EACEwI,GAAShI,CAATgI,KAAmBuE,GAAWvM,CAAXuM,CADrB/M,EAEE,oCAFFA,CFRK;;AEaP,MAAMuZ,KAAoB,CACxB/Y,CADwB,EAExBsG,CAFwB,EAGxB0S,CAHwB,EAIxBC,CAJwB,KAMxBzZ,KAEMwI,GAAShI,CAATgI,CAFNxI,IAEeQ,CAAWuM,GAAWvM,CAAXuM,CAF1B/M,IAEqCQ,EAC9B,YAAYA,CADkBA,KAClBA,EAAY,cAAcA,CAA1BA,CAHnBR,GAKG,GAAE8G,aAAkB0S,0CAAkDC,GALzEzZ,CANF;;AAcO,IAAMwL,KAAgB,CAAChL,CAAD,EAAQsG,CAAR,EAAwB0S,CAAxB,KAAwBA;AAC/C/V,QAAMC,OAAND,CAAcjD,CAAdiD,IACF5D,EAAQW,CAARX,EAAe,CAACmC,CAAD,EAAO2B,CAAP,KACb4V,GAAkBvX,CAAlBuX,EAAwBzS,CAAxByS,EAAiC,GAAE5V,aAAa6V,GAAhDD,EAA6D,EAA7DA,CADF1Z,CADE4D,GAKF8V,GAAkB/Y,CAAlB+Y,EAAyBzS,CAAzByS,EAAiCC,CAAjCD,EAA4C,oBAA5CA,CALE9V;AAK0C,CANzC;AAAA,IAUM8Q,KAAe,UAC1BzN,CAD0B,EAE1B3F,CAF0B;AAAA,MAG1BuY,CAH0B,uEAGJ,QAHI;AAAA,SAK1B7Z,EAAQ+B,GAAYT,CAAZS,CAAR/B,EAA6BmC,KAC3BgH,GACGtI,GAAQsB,CAARtB,EAAc,SAAdA,CADHsI,EAEG,GAAElC,uBAA4B4S,IAFjC1Q,EAGG,yBAHHA,CADFnJ,CAL0B;AAAA,CAVrB;AAAA,IC9BM4M,KAAgB,CAC3BlJ,CAD2B;AAAA,MAC3BA;AACCxD;AADDwD,GAD2B;AAAA,MAE1BxD;AACAuN;AADAvN,GAF0B;AAAA,SAIxBA,EAAGwD,CAAHxD,EAAUuN,CAAVvN,CAJwB;AAAA,CD8BtB;AAAA,ICzBMgM,KAAgB,CAC3BxI,CAD2B;AAAA,MAC3BA;AACCxD;AADDwD,GAD2B;AAAA,MAE1BxD;AACAuN;AADAvN,GAF0B;AAAA,SAIxBA,EAAGuN,CAAHvN,EAAMwD,CAANxD,CAJwB;AAAA,CDyBtB;AAAA,ICpBM6J,KAAY,CAACrG,CAAD;AAAA,MAACA;AAAaxD;AAAbwD,GAAD;AAAA,SACvBxD,EAAGwD,CAAHxD,CADuB;AAAA,CDoBlB;;AElBP,MAAM4Z,KAAM,CACVlY,CADU,EAEV8D,CAFU,EAGVP,CAHU,EAIV2R,CAJU,KAIVA;AAAAA,MAEMzU,IAAS;AACbC,QAAI6W,IADS;AAEbvX,WAFa;AAGb8D;AAHa,GAFfoR;AAKEpR,SAEEP,MACF9C,EAAO6C,KAAP7C,GAAe;AAAC8C;AAAD,GAAf9C,EACIyU,MAAOzU,EAAO6C,KAAP7C,CAAa+C,SAAb/C,GAAa+C,EAAc2U,EAAlCjD,CAFF3R,GAIG9C,CANLqD;AAMKrD,CAfT;;AAkBA,IAAI0X,KAAgB,CAApB;AAAA,IAEarM,KAkDT;AAAA;AACFvM,chCrFmB,OgCoFjB;AAEFyE,YAFE;AAGFtE,aAHE;AAIFD,YAAKC,IhCxFc,OgCwFdA,GAAiBqE,CAJpB;AAKFmR,YALE;AAMF3R;AANE;AAAA,SAcE2U,GAAI,KAAJA,EAAW;AAAC3Y,WAAD;AAAOyE,YAAP;AAAcvE,SAAd;AAAkBC;AAAlB,GAAXwY,EAAsC3U,CAAtC2U,EAAgDhD,CAAhDgD,CAdF;AAAA,CApDJ;AAAA,IAoEa9E,KAAU;AAAA;AACrB9U,SADqB;AAErB4W,YAFqB;AAGrB3R,eAHqB;AAIrBoB,cAAO,CAJc;AAKrBE,gBAAS,CALY;AAMrBJ,cAAO;AANc;AAAA,SAcRyT,GAAI,SAAJA,EAAe;AAAC5Z,SAAD;AAAKqG,WAAL;AAAWE,aAAX;AAAmBJ;AAAnB,GAAfyT,EAAyC3U,CAAzC2U,EAAmDhD,CAAnDgD,CAdQ;AAAA,CApEvB;AAAA,IA4FaE,KAAM;AAAA;AAAE9Z;AAAF;AAAA,SACjB8U,GAAQ;AAAC9U,SAAD;AAAKiF,chC3HO;AgC2HZ,GAAR6P,CADiB;AAAA,CA5FnB;AAAA,IA+Fa/K,KAAO,CAClB/J,CADkB,EAElBuG,CAFkB,EAGlBwT,CAHkB,KAIfjF,GAAQ;AAAC9U,OAAD;AAAKqG,QAAM,CAAX;AAAiBE,WAAjB;AAAyBtB,YAAU8U,KhCjI1B;AgCiIT,CAARjF,CAnGL;AAAA,IA+GaxH,KAAO,CAClB5H,CADkB,EAElBsU,CAFkB,EAGlBC,CAHkB,KAKlBzM,GAAI;AACF9H,UADE;AAEFvE,MAAI6Y,IAAUvU,CAAVuU,GhCzIa,GgCuIf;AAGF/U,YAAUgV,KhClJS,SgC+IjB;AAIFrD,SAAO;AAJL,CAAJpJ,CApHF;AAAA,IA2Ha5D,KAAa;AAAA,MACxB5J,CADwB,uEACkC6J,EADlC;AAAA,MAExBqQ,CAFwB;AAAA,SAGrBpF,GAAQ;AAAC9U,SAAD;AAAKmG,UAAM,CAAX;AAAiBI,YAAQ2T;AAAzB,GAARpF,CAHqB;AAAA,CA3H1B;AAAA,IAgIa/P,KAAO;AAACyI,SAAD;AAAMsH,aAAN;AAAevO,UA5Cb;AAAA;AACpBvG,WADoB;AAEpBmG;AAFoB;AAAA,WAMhB2O,GAAQ;AAAC9U,WAAD;AAAKuG,cAAQ,CAAb;AAAmBJ;AAAnB,KAAR2O,CANgB;AAAA,GA4CF;AAAuBgF;AAAvB,CAhIpB;AAAA,IC5BarP,KAAkBvE;AAC7B9D,MAAI6W,IADyB/S;AAE7BA;AAF6BA,ED4B/B;AAAA,ICxBaF,KAAU;AAAA;AAAEE;AAAF;AAAA,SAAqCA,CAArC;AAAA,CDwBvB;AAAA,ICtBayG,KAAW,CAACwN,CAAD,EAAgB/J,CAAhB,KAAgBA;AACjC+J,IAAIC,MAAJD,KAAYA,EAAIC,MAAJD,GAAa,EAAzBA,GACLjY,EAAIiY,EAAIC,MAARlY,EAAiBkO,CAAjBlO,CADKiY;AACY/J,CDoBnB;AAAA,I/B2BIiK,KAAyB,I+B3B7B;;A/B6BA,MAAMpH,KAAQ,CAAC1F,CAAD,EAAsBF,CAAtB,KAAsBA;AAAAA,OAC7BE,CAD6BF,EAC1B,OAAOA,CAAP;AAAOA,OACVA,CADUA,EACP,OAAOE,CAAP;AAAOA,MAEX+M,CAFW/M;AAEX+M,UAMD/M,EAAEgN,CAAFhN,CAAI7L,IAAJ6L,KAAaF,EAAEkN,CAAFlN,CAAI3L,IAAjB6L,IAAyBA,EAAEgN,CAAFhN,CAAInL,EAAJmL,GAASF,EAAEkN,CAAFlN,CAAIjL,EAAtCmL,IAKDiN,GAAYjN,EAAEgN,CAAFhN,CAAI7L,IAAhB8Y,IAAwBA,GAAYnN,EAAEkN,CAAFlN,CAAI3L,IAAhB8Y,CAXtBF,MAaFA,IAAM/M,CAAN+M,EACA/M,IAAIF,CADJiN,EAEAjN,IAAIiN,CAfFA,GAiBJA,IAAMrH,GAAM1F,EAAEkN,CAARxH,EAAW5F,CAAX4F,CAjBFqH,EAkBJ/M,EAAEkN,CAAFlN,GAAMA,EAAEmN,CAlBJJ,EAmBJ/M,EAAEmN,CAAFnN,GAAM+M,CAnBFA,EAqBG/M,CArBH+M;AAqBG/M,CAzBT;AAAA,MA6BMoN,KAAuB,EA7B7B;;AA8BA,IAAIC,KAAK,CAAT;;AACA,OAAOA,KAAK,CAAZ,GAKE1Y,EAAIyY,EAAJzY,EAAW;AAAC2Y,SAAO,IAAR;AAAcC,QAAM,IAApB;AAA0BC,QAAM;AAAhC,CAAX7Y,GACA0Y,MAAM,CADN1Y;;AAIF,MAAMsC,KAAY;AAAA,OACX,IAAIZ,IAAI,CADG,EACAA,IAAI,CADJ,EACOA,GADP,EACY;AAAA,QACpB7D,IAAO4a,GAAM/W,CAAN+W,CADa;;AACP/W,QACf7D,EAAKgb,IAALhb,GAAY,CADG6D,EACA;AAAA,UAKP,MAANA,CAAM,IAAW,MAANA,CALE,EAKO;AACtB7D,UAAKgb,IAALhb,IAAa,CAAbA;AAAa,YACPU,IAAQ4Z,GAAME,CADP;AACOA,eACpBF,KAAOpH,GAAMoH,GAAMK,CAAZzH,EAAeoH,GAAMI,CAArBxH,CAAPoH,EACO5Z,CAFa8Z;AAIJ;;AAAA,YAAdxa,EAAKgb,IAAS,KAChBhb,EAAK+a,IAAL/a,GAAY,IADI;AACJ,UAERkC,IAAOlC,EAAK8a,KAFJ;AAEIA,aAClB9a,EAAK8a,KAAL9a,GAAakC,EAAMwY,CAAnB1a,EACAA,EAAKgb,IAALhb,IAAa,CADbA,EAEOkC,EAAMsY,CAHKM;AAGLN;AAAAA;AAAAA,CApBnB;AAAA,MAwBMzW,KAAoB,CACxBpC,CADwB,EAExB6B,CAFwB,EAGxBvC,CAHwB,EAIxBR,CAJwB,EAKxBC,CALwB,EAMxBa,CANwB,KAQxBgE,GACE,CADFA,EAEE;AACEiI,KAAG,IADL;AAEEF,KAAG,IAFL;AAGErM,SAHF;AAIER,WAJF;AAKEC,UALF;AAME8C,SANF;AAOEjC;AAPF,CAFFgE,EAWE5D,CAXF4D,CAhCF;AAAA,MA6CMA,KAAW,UACfb,CADe,EAEfjB,CAFe,EAGf9B,CAHe,EAIF;AAAA,MAAbU,CAAa;AAAA,MAEP6C,IAAWuV,GAAY9Y,CAAZ8Y,CAFJ;AAAA,MAGPQ,IAAsBL,GAAM1V,CAAN0V,CAHf;AAAA,MAIP1Y,IAAkB;AACtBsY,OAAG;AACD9V,YADC;AAEDjB,cAFC;AAGD9B,aAHC;AAIDU;AAJC,KADmB;AAOtBsY,OAAG,IAPmB;AAQtBD,OAAG;AARmB,GAJX;AAkBI,QAAbxV,CAAa,IAAkB,MAAbA,CAAL,GACfoV,KAAOpH,GAAMoH,EAANpH,EAAYhR,CAAZgR,CADQ,IAGK,MAAhB+H,EAAOD,IAAS,GAClBC,EAAOH,KAAPG,GAAe/Y,CADG,GAGlB+Y,EAAOF,IAAPE,CAAaP,CAAbO,GAAiB/Y,CAHC,EAKpB+Y,EAAOF,IAAPE,GAAc/Y,CARC,GAUjB+Y,EAAOD,IAAPC,IAAe,CAVE;AAUF,CA7EjB;AAAA,MAgFMR,KAAeS;AAAAA,UACXA,CADWA;AACXA,SACD,OADCA;AACD,aACI,CADJ;;AACI,SACJ,MADI;AACJ,aACI,CADJ;;AACI,SACJ,MADI;AACJ,aACI,CADJ;;AACI,SDnLU,SCmLV;ADnLU,aCqLV,CDrLU;;ACqLV,SDzLU,SCyLV;ADzLU,aC2LV,CD3LU;;AC2LV,SD9LS,QC8LT;AD9LS,aCgMT,CDhMS;;ACgMT;AAAA,cAEC,CAFD;AAbQA;AAeP,CA/Fd;AAAA,MAmGM7V,KAAW,IAAIkN,GAAJ,EAnGjB;;AAqGA,IAIWlP,EAJX;AAAA,IAAIY,KAAS,CAAb;AAAA,IACWK,KAAU,CADrB;AAAA,IAEWC,KAAS,CAFpB;AAAA,IAGWrB,KAA2B,IAHtC;AAAA,IAKasN,KAAe2K;AAC1B9X,OAAW8X,CAAX9X;AAAW8X,CANb;AAAA,IAQa/R,KAAkBgS;AAC7BlY,OAAckY,CAAdlY;AAAckY,CAThB;;AAYA,MAAMvV,KAAgB,CAACrC,CAAD,EAAoBnB,CAApB,KAAoBA;AAAAA,MACpCmB,CADoCnB,EAC9B;AAAA,WACDmB,MAASA,EAAKY,GAALZ,CAASnB,CAATmB,CADR,GAENA,IAAOzC,GAAUyC,CAAVzC,CAAPyC;;AAAiBA,QAEfA,CAFeA,EAET,OAAOA,CAAP;AAAOA;;AAAAA,SAEZ,IAFYA;AAEZ,CAPT;;AASO,IAAM0C,KAAa,CACxB1C,CADwB,EAExBH,CAFwB,EAGxBpC,CAHwB,EAIxBmZ,CAJwB,EAKxBiB,CALwB,KAKxBA;AAAAA,MAEMzV,IAAaC,GAAcrC,CAAdqC,EAAoBuU,EAAI/X,EAAxBwD,CAFnBwV;AAE2ChZ,SACvCuD,IAAmBA,EAAWxB,GAAXwB,CAAewU,EAAI/X,EAAnBuD,CAAnBA,GACAvC,KACFyC,GAAezC,CAAfyC,EAA0BsU,CAA1BtU,EAA+BuV,CAA/BvV,GACOzC,EAASe,GAATf,CAAa+W,EAAI/X,EAAjBgB,CAFLA,IAIG+W,CANoC/X;AAMpC+X,CAbF;AAAA,IAoPMtU,KAAiB,CAC5BvE,CAD4B,EAM5B+Z,CAN4B,EAO5BD,CAP4B,EAQ5BE,CAR4B,EAS5BxV,CAT4B,KAS5BA;AAAAA,MAEMyV,IAAUja,EAAM6C,GAFtB2B;AAAAA,MAGM2H,IAAM4N,EAAU5N,GAHtB3H;AAGsB2H,MAClB8N,EAAQF,EAAUjZ,EAAlBmZ,CADkB9N,EACK;AAAA,MACrB0M,IAAgB;AACpB/X,QAAIiZ,EAAUjZ,EADM;AAEpB8D,aAASmV,EAAUnV;AAFC,GADK;AAGNA,MAGjBuH,KAAOA,KAAOnM,EAAM2V,YAApBxJ,IAAoBwJ,EAAkBxJ,KAAOnM,EAAM0V,QAA/BC,CAHH/Q,EAInBiU,EAAIjU,OAAJiU,GAAc7Y,EAAM2V,YAAN3V,CAAmBmM,CAAnBnM,CAAd6Y,CAJmBjU,KAIcuH,IAE7B4N,EAAUjB,MAAViB,IAAUjB,CAAWtU,CAFQ2H,EAEE;AAAA,QAC7B+N,IAAU,CADmB;AAAA,QAE3BjE,IAAe6D,MAAeC,EAAUxO,MAAzBuO,IAAmCE,CAFvB;AAGjCxb,MAAQub,EAAUjB,MAAlBta,EAA0B8Z;AAAAA,cAChBA,EAAIlY,IADYkY;AACZlY,aACLiI,CADKjI;AACLiI;AAAAA,gBACG1I,IAAO2Y,EAAI3Y,IADd0I;;AACc1I,gBACbA,KAAQ2Y,EAAI5Z,EADCiB,EACG;AACdA,mBAAM4E,GAAevE,CAAfuE,EAAsB5E,CAAtB4E,EAA4BuV,CAA5BvV,EAAwCyV,CAAxCzV,CAAN5E;AAA8Cqa,kBAC5C7a,IAAQQ,KAAQsa,EAAQta,EAAKmB,EAAbmZ,EAAiBrV,OADWoV;AAE9C/D,oBACF4C,EAAIjU,OAAJiU,GAAcP,EAAI5Z,EAAJ4Z,GAASA,EAAI5Z,EAAJ4Z,CAAOnZ,CAAPmZ,CAATA,GAAyBnZ,CADrC8W;AACqC9W;;AAAAA;AAAAA;;AAAAA,aAKxC,OALwCA;AAMtC+a,gBACHA,IAAU,CAAVA,EAEErB,EAAIjU,OAAJiU,GADEzW,MAAMC,OAAND,CAAcyW,EAAIjU,OAAlBxC,IACY,IAAIyW,EAAIjU,OAAR,CADZxC,GAGY,KAAIyW,EAAIjU;AAAR,WALbsV,GAQL3V,GAAevE,CAAfuE,EAAsB+T,EAAI3Y,IAA1B4E,EAAgCuV,CAAhCvV,EAA4CyV,CAA5CzV,CARK2V,EASDjE,MAEF4C,EAAIjU,OAAJiU,CAAYP,EAAIvG,KAAhB8G,IAAyBoB,EADZA,EAAQ3B,EAAI3Y,IAAJ2Y,CAASxX,EAAjBmZ,EACyBnZ,EAAbmZ,EAAiBrV,OAFxCqR,CATCiE;AAde5B;AAyBwB1T,KAzBlDpG;AAmCA2N;AAAAA,QAAKnM,EAAM0V,QAAN1V,CAAemM,CAAfnM,IAAsB+Z,EAAUjZ,EAArCqL,GACJ8N,EAAQF,EAAUjZ,EAAlBmZ,IAAwBpB,CADpB1M;AACoB0M,CAjTnB;;AAqTP,MAAM7T,KAAS,CAAC1B,CAAD,EAAe5E,CAAf,EAA6BwD,CAA7B,KAA6BA;AAAAA;AAAAA,WAEjCxD,EAAG4C,EAASY,CAATZ,CAAH5C,EAAoB4E,EAAMtD,KAA1BtB,EAAiCwD,CAAjCxD,CAFiCwD;AAGxC,GAHwCA,CAGxC,OAAOmL,CAAP,EAAOA;AACPgK,YAAQpJ,KAARoJ,CAAchK,CAAdgK,GACA/T,EAAMC,IAAND,GAAa,CADb+T;AACa;AAAA,CALjB;;AEleO,IAAM8C,KAAgB,UAACC,CAAD;AAAA,MAAOtP,CAAP,uEAAgB,EAAhB;AAAA,SACvB3D,GAASiT,CAATjT,MACFgT,GAAcC,EAAKrT,EAAnBoT,EAAuBrP,CAAvBqP,GACA/b,EAAMgc,CAANhc,EAAY,CAACe,CAAD,EAAQ4S,CAAR,KAAQA;AACbrJ,OAAOvJ,CAAPuJ,KAA2B,SAAVqJ,CAAjBrJ,IAA6C,UAAVqJ,CAAnCrJ,KACHoC,EAAOiH,CAAPjH,IAAgB3L,CADbuJ;AACavJ,GAFpBf,CADA+b,EAMAA,GAAcC,EAAKnT,GAAnBkT,EAAwBrP,CAAxBqP,CAPEhT,GASG2D,CAVoB;AAAA,CAAtB;;A+B5CP,MAAMuP,KAAiB,CAACC,CAAD,EAAoBC,CAApB,KAAoBA;AACzCxD,IAAWuD,EAAYtZ,IAAvB+V,EAA6BwD,CAA7BxD,GACAA,EAAW7V,EAAUoZ,CAAVpZ,CAAX6V,EAAmCwD,CAAnCxD,CADAA,EAEAA,EAAW3V,EAASkZ,CAATlZ,CAAX2V,EAAkCwD,CAAlCxD,CAFAA;AAEkCwD,CAHpC;AAAA,MAKMC,KAAsB,CAC1BD,CAD0B,EAE1BE,CAF0B,EAG1BC,CAH0B,KAG1BA;AAAAA,MAMIJ,CANJI;AAEAH,IAAWvZ,IAAXuZ,CAAgBhY,MAAhBgY,GAAyB,CAAzBA,EACAA,EAAW7Z,GAAX6Z,CAAehY,MAAfgY,GAAwB,CADxBA,EAGAA,EAAWva,KAAXua,GAAmB,IAHnBA;AAGmB,MAEf9b,IAAO2C,EAASmZ,CAATnZ,CAFQ;;AAECmZ,SACZD,IAAc7b,EAAKkc,GAALlc,EADF8b,GAElBF,GAAeC,CAAfD,EAA4BE,CAA5BF,GAA4BE,CAE1BE,KACCC,KAA8C,aAA9Brb,GAAQkb,CAARlb,EAAoB,IAApBA,CADjBob,IlCnBmB,gBkCqBnBH,EAAYpa,MAAZoa,CAAmBla,IAJOma,KAM1BC,GACEF,CADFE,EAEEC,CAFFD,EAGiC,SAA/Bnb,GAAQib,CAARjb,EAAqB,IAArBA,CAA+B,IAAQqb,CAHzCF,CANFH;;AAS2CK,OAI7Cjc,IAAOyC,EAAUqZ,CAAVrZ,CAJsCwZ,EAKrCJ,IAAc7b,EAAKkc,GAALlc,EALuBic,GAM3CL,GAAeC,CAAfD,EAA4BE,CAA5BF,GACIK,KlCjCiB,gBkCiCDJ,EAAYpa,MAAZoa,CAAmBla,IAAnCsa,IACFF,GACEF,CADFE,EAEEC,CAFFD,EAGiC,SAA/Bnb,GAAQib,CAARjb,EAAqB,IAArBA,CAA+B,IAAQqb,CAHzCF,CAFFH;AAK2CK,CArC/C;AAAA,MA0CME,KAAYzS,KAAkCA,EAAI0S,KAAJ1S,EA1CpD;;AA0CwD0S,IAC3CC,KAAY,UACvB/S,CADuB,EAMnB;AAAA,MALJA;AAEE0S;AAFF1S,GAKI;AAAA,MAEA2S,IAAe,CAFf;AAEe,MAEf3S,EAASmJ,QAATnJ,IAAmBA,EAASmJ,QAATnJ,CAAkB9D,MAAlB8D,CAAyBA,CAAzBA,CAAnBA,EACAnC,EAASmC,CAATnC,CAHe,EAIjBgV,GAAStQ,GAAevC,CAAfuC,CAATsQ,EAJiB,KAKZ,IAAIhV,EAAUmC,CAAVnC,CAAJ,EAAyB;AAC9B8U,QAAe,CAAfA;AAAe,QACTrK,IAAUtI,EAASsI,OADV;AAEfuK,OAASvK,EAAQ0K,MAAjBH,GACAA,GAASvK,EAAQ2K,OAAjBJ,CADAA,EAEAA,GAASvK,EAAQ9D,MAAjBqO,CAFAA,EAGAA,GAASvK,EAAQ4K,OAAjBL,CAHAA;AAKFJ;AAAAA,KAAoB/X,EAASsF,CAATtF,CAApB+X,EAA6BzS,EAAa0S,CAA1CD,EAAgDE,CAAhDF;AAAgDE,CAtBMG;AAAAA,IC7C3CrQ,KAAsB9K;AAAAA,MAC3BmB,IAAS,MAAMia,GAAUpb,CAAVob,CADYpb;;AACFA,SAC/BmB,EAAOqa,WAAPra,GAAqBA,CAArBA,EACOA,CAFwBnB;AAExBmB,CD0C+Cga;AAAAA,IE1C3ChS,KAAiB,CAC5B3J,CAD4B,EAE5Ba,CAF4B,EAG5BL,CAH4B,EAI5BoP,CAJ4B,EAK5BqM,CAL4B,KAO5B1b,EAAW;AACTC,SADS;AAETR,WAFS;AAGTa,UAHS;AAITC,SAAO;AAACtB,QAAIyc;AAAL,GAJE;AAKTlb,QAAM;AAAC6O;AAAD,GALG;AAMT5O,UAAQ;AAACO,YAAQ,CAACvB,CAAD,EAASa,CAAT,CAAT;AAA0BS,WAAOT;AAAjC,GANC;AAOTM,YAAU;AAPD,CAAXZ,CFmCsDob;AAAAA,IE1B3CO,KAAWC;AAAAA,MAKhB5V,IAAS,SALO4V;AAAAA,MAKP;AACR1b,UAACA,CADO;AACRE,QAAOA;AADC,KACIiL,CADJ,IACcrE,EAAoB4U,CAApB5U,EAA0B,CAA1BA,CANP4U;AAMiC,SACvDlR,GAAcxK,CAAdwK,EAAoB1E,CAApB0E,EAA4B,QAA5BA,GACAA,GAActK,CAAdsK,EAAkB1E,CAAlB0E,EAA0B,MAA1BA,CADAA,EAEA+I,GAAazN,CAAbyN,EAAqBrT,CAArBqT,EAAyB,IAAzBA,CAFA/I,EAGOK,GACL/K,EAAW;AACTP,YAAQS,CADC;AAETI,WAAOF,CAFE;AAGTI,UAAM;AAAC6O,UAAIrJ,CAAL;AAAaqF;AAAb,KAHG;AAIT5K,YAAQ,EAJC;AAKTG,cAAU;AALD,GAAXZ,CADK+K,CAJgD;AAUzC,CFUwCqQ;AAAAA,IGxC3C3S,KAAY,CACvBlJ,CADuB,EAEvBsN,CAFuB,MAIvB3N,EAAO+M,GAAWY,CAAXZ,CAAP/M,EAA4B,sCAA5BA,GACO6L,GACL/K,EAAW;AACTO,SAAO;AAACtB,QAAI4N;AAAL,GADE;AAET5M,QAAM,CAAC8Y,GAAI;AAAC9Z,QAAI6J;AAAL,GAAJiQ,CAAD,CAFG;AAGTtZ,UAAQF,CAHC;AAITiB,QAAM;AAAC6O,QAAI;AAAL,GAJG;AAKT5O,UAAQ;AAACO,YAAQzB;AAAT,GALC;AAMTqB,YAAU;AAND,CAAXZ,CADK+K,CALgB,CHwC+BqQ;AAAAA,I7BA3C/R,KAAkB,UAC7BlJ,CAD6B,EAE7BE,CAF6B,EL/CV;AAAA,MKkDnBwb,CLlDmB;AKoDf9b,KAAUI,CAAVJ,KAAmBA,GAAUI,CAAVJ,EAAkB8Q,KAAlB9Q,CAAwB8b,CAAxB9b,EAAkCM,CAAlCN,CAAnBA;AAAqDM,C6BLH+a;AAAAA,I7BQ3C7S,KAAW,CAACwF,CAAD,EAAOxO,CAAP,EAAauc,CAAb,EAAsBC,CAAtB,KAAsBA;AAAAA,MACtCC,ILtDc,aKsDHjO,CAD2BgO;AAAAA,MAEtC1a,IAAK4W,IAFiC8D;AAAAA,MAGtC1Q,IAASqP,GAAc;AAC3BpT,QAAIyU,CADuB;AAE3BvU,SAAwB,mBAAZsU,CAAY,GAAW;AAAC7V,YAAM6V;AAAP,KAAX,GAA6BA;AAF1B,GAAdpB,CAH6BqB;AAAAA,MAKWD;AAEjDrc,YAACA,IAAS,IAFuCqc;AAEjDpP,SAAgBA,IAAM,IAF2BoP;AAEjDxN,WAA4BA,IAAQ;AAFawN,MAELzQ,CAPN0Q;AAAAA,MAQtC9V,IAAOqI,KAAgBjD,EAAOpF,IAAvBqI,KAAgC0N,IAAW,EAAXA,GAAgB3a,CAAhDiN,CAR+ByN;AAAAA,MAStChE,IAAgBnR,EAAWX,CAAXW,EAAiBnH,CAAjBmH,CATsBmV;AAAAA,MAUtCvb,IAA4B;AAChC6O,QAAK9P,EAAKwO,IAALxO,GAAYwO,CADe;AAEhC9H,UAAO1G,EAAKkH,SAALlH,GAAiB0G,CAFQ;AAGhCyG,SAAMnN,EAAKmN,GAALnN,GAAW4Y,GAAYzL,CAAZyL,CAHe;AAIhC7J,YAJgC;AAKhC2N,YAAS1c,EAAK8B,EAAL9B,GAAU8B,CALa;AAMhC2V,eAAW3L,EAAO2L,SANc;AAOhCvL,aAASJ,EAAOI,OAPgB;AAQhCJ;AARgC,GAVU0Q;;AAkB1C1Q,MAEF9L,EAAKE,MAALF,GAAcE,CAAdF,EACAA,EAAKwY,aAALxY,GAAqBwY,CADrBxY,EAEAA,EAAK4M,aAAL5M,GAAqB8L,CAFrB9L,EAGAA,EAAK2c,IAAL3c,GAAaN,MACXiJ,EAAU,CAAVA,EAAiB,MAAjBA,EAAyB,SAAzBA,GACOjJ,EAAGM,CAAHN,CAFIA,CAHbM,EAOAA,EAAKqP,OAALrP,GAAe,MAAMwY,EAAc1R,QAPnC9G,EAOmC8G,CAC9B2V,CAVH3Q,EAUa;AACb9L,MAAKwS,SAALxS,GAAkB4c,MAChB/U,GAAa+U,CAAb/U,GACO7H,EAAKiJ,KAALjJ,CACL0M,GAAWkQ,CAAXlQ,IACIkQ,CADJlQ,GAEIG,KAAO+P,EAAS5a,IAAT4a,IAAiBA,EAAS5a,IAAT4a,CAAc/P,CAAd+P,CAHvB5c,CAFS4c,CAAlB5c,EAQAA,EAAKuS,CAALvS,IAAyB,MAAMA,CAR/BA;AAQ+BA,QACzBI,IAAWE,IADcN;AAE3BI,UAAUa,EAAK4b,cAAL5b,GAAsBb,CAAhCA;AAAgCA;;AAAAA,SAE/Ba,CAF+Bb;AAE/Ba,C6BjD+C4a;AAAAA,I7BmD3CxR,KAAoB0E,KAAkBxG,EAAY;AAACwG;AAAD,CAAZxG,C6BnDKsT;;A7BqDxD,MAAMzS,KAAc,CAACV,CAAD,EAAQoH,CAAR,EAAoBpQ,CAApB,EAAwBgB,CAAxB,KAAwBA;AAAAA,MACtCoL,CADsCpL;AAEtCyH,KAASzI,CAATyI,MACF2D,IAASpM,CAAToM,EACApM,IAAKA,EAAGA,EAFNyI;AAEMzI,MAEJod,IAASvU,EAAY;AACzB7B,UAAO,GAAEgC,EAAMxB,oBADU;AAEzBgF,aAAS,CAFgB;AAGzBjE,SAAK6D;AAHoB,GAAZvD,CAFL7I;AAKHoM,SAEPjC,GAAenB,CAAfmB,EAAsBiT,CAAtBjT,EAA8BnJ,CAA9BmJ,EAAoCiG,CAApCjG,EAAwCnK,CAAxCmK,GACOiT,CAHAhR;AAGAgR,CAZT;AAAA,MAwOMrR,KAAc,CAClB9K,CADkB,EAElByE,CAFkB,EAGlB0K,CAHkB,EAIlBiN,CAJkB,EAKlBrd,CALkB,KAKlBA;AAAAA,MAEMuV,IAAW3I,EAAclH,CAAdkH,CAFjB5M;AAAAA,MAGMsd,IAAS9P,GAAI;AACjB9H,WAAO6P,CADU;AAEjBpU,QL1UiB,GKwUA;AAGjB8D,cAAU;AAHO,GAAJuI,CAHfxN;AAQIoQ,QAAOzG,CAAPyG,KAAYkN,EAAO9X,IAAP8X,CAAYxX,QAAZwX,GAAuB,CAAnClN;AAAmC,MACjCpP,IAAO,CAACsc,CAAD,EAAS1T,GAAWyT,CAAXzT,CAAT,CAD0B;AACNyT,SACjC1U,EACE,YADFA,EAEE4M,CAFF5M,EAGE3H,CAHF2H,EAIEzB,EAASjG,CAATiG,KAAkB0F,EAAc3L,CAAd2L,CAJpBjE,GAMOwB,GAAelJ,CAAfkJ,EAAqBzE,CAArByE,EAA4BnJ,CAA5BmJ,EAAkCiG,CAAlCjG,EAAsCnK,CAAtCmK,CAP0BkT;AAOYrd,CA7P/C;AAAA,MCrBMmO,KAAmB,CACvBxK,CADuB,EAEvB4Z,CAFuB,EAGvB5d,CAHuB,EAIvByM,CAJuB,EAKvBpM,CALuB,KAKvBA;AAAAA,MAEMwd,IAAQ7Z,IAAU5D,KAAQA,EAAKmO,KAALnO,EAAlB4D,GAAiChE,WAAYA;AAAZA,IAF/CK;AAAAA,MAGMsK,IAAe3G,IAAU,EAAVA,GAAe,EAHpC3D;AAAAA,MAKMyd,IAAWD,EAAMlT,CAANkT,CALjBxd;AAAAA,MAMM0d,IAAWjT,GAAegT,CAAfhT,CANjBzK;AAAAA,MAOMwb,IAAU/Q,GAAe,CAAfA,CAPhBzK;AAQA0d,IAAShc,IAATgc,GAAgB/Z,IAAU,MAAVA,GAAmB,OAAnC+Z,EACAA,EAAS7Q,MAAT6Q,GAAkB,CADlBA,EAEA/U,EAAc,aAAdA,EAA6B+U,CAA7B/U,EAAuC6S,CAAvC7S,CAFA+U;AAEuClC,MACjC9V,IAAQ2E,EAAYoT,CAAZpT,EAAsB;AAClCrD,UAAMH,EAAelH,CAAfkH,CAD4B;AAElC2F,aAAS,CAFyB;AAGlCjE,SAAK6D;AAH6B,GAAtB/B,CADyBmR;AAAAA,MAMjCmC,IAAgB/Q,EAAclH,CAAdkH,CANiB4O;AAOvCmC,IAAc9Q,MAAd8Q,GAAuB,CAAvBA,EACAjQ,GAAQhI,CAARgI,EAAe,WAAfA,EAA4B,CAA5BA,CADAiQ;AAC4B,MACtBC,IAAiBtQ,GAAKoQ,CAALpQ,CADK;AAO5BsQ,IAAe5Y,KAAf4Y,GAAuB;AAAC3Y,cAAU;AAAX,GAAvB2Y;AAAkC,MAC5B5c,IAAO,CACX+I,GAAK,CAACoD,CAAD,EAAMC,CAAN,EAAS5J,CAAT,MACCA,EAAMlC,KAANkC,IAAMlC,CAAUkC,EAAMlC,KAANkC,CAAYW,GAAZX,CAAgBka,EAAStb,EAAzBoB,CAAhBA,KACFA,EAAMqa,CAANra,GAAU,CADRA,GAGG2J,CAJJ,CAALpD,CADW,EAOX6T,CAPW,EAQXpQ,GAAI;AAAC9H,WAAO8V,CAAR;AAAiBra,QAAI;AAArB,GAAJqM,CARW,EASXzD,GAAK,CAACoD,CAAD,UAAahJ,CAAb,KAAaA;AAAAA,QAAZgJ;AAAMtN;AAANsN,KAAYhJ;AAAAA,QACZA,EAAI0Z,CAAJ1Z,IAASgJ,MAAQhJ,EAAIoJ,CAAJpJ,CAAMtE,CAANsE,CADLA,EACWtE,OACrB0d,KAAcpZ,EAAIkJ,CAAlBkQ,KACFpZ,EAAIoJ,CAAJpJ,GAAQqZ,EAAMrZ,EAAIoJ,CAAViQ,CADND,GAGJpZ,EAAIoJ,CAAJpJ,CAAMtE,CAANsE,IAAagJ,CAHToQ,EAIG,CALkB1d;AAKlB,GANXkK,EAQG,CARHA,CATW,EAkBXyD,GAAI;AAACvM,UNpHY,GMoHb;AAAcG,YAAQsc;AAAtB,GAAJlQ,CAlBW,EAmBXA,GAAI;AAACvM,UNxHY,OMwHb;AAAcyE,WAAO,CAArB;AAA4BtE,YAAQoa;AAApC,GAAJhO,CAnBW,EAoBXA,GAAI;AACFvM,UN1He,OMyHb;AAEFyE,WAAO,CAFL;AAGFtE,YAAQoa,CAHN;AAIFvW,cN9HiB,SM0Hf;AAKF2R,WAAO;AALL,GAAJpJ,CApBW,EA2BXF,GAAKoQ,CAALpQ,EAAe,CAAfA,CA3BW,EA4BXtN,KAAM4J,IA5BK,CADqB;AA6B1BA,SAERlK,EAAMC,CAAND,EAAW,CAAC2B,CAAD,EAA0BxB,CAA1B,KAA0BA;AAAAA,SAC9BqH,EAAS7F,CAAT6F,CAD8BrH,EACrBwB,OACZpB,GACGiH,EAAQ7F,CAAR6F,CADHjH,IACWoB,CAAW2I,GAAO3I,CAAP2I,CADtB/J,EAEG,sCAAqCJ,GAFxCI,GAEwCJ,MAExC4d,EAAS5d,CAAT4d,IAAgBnT,EAAazK,CAAbyK,IAAoBjJ,CAFIxB,CAH5BwB;AAQdiJ,MAAazK,CAAbyK,IAAoBjJ,EAAMiJ,YAA1BA,EACAmT,EAAS5d,CAAT4d,IAAgBpc,EAAM2J,QAAN3J,EADhBiJ;AACsBU,QAChByB,IAAWtC,GAAe9I,CAAf8I,EAAsBzE,CAAtByE,EAA6BnJ,CAA7BmJ,EAAmC,SAAnCA,EAA8CnK,CAA9CmK,CADKa;AAEtByB,MAASnL,KAATmL,CAAe5M,GAAf4M,GAAqB5M,CAArB4M;AAAqB5M,QACfie,IAAWlR,EAAcvL,CAAduL,CADI/M;AAErB8M,OAAS+Q,CAAT/Q,EAAmB;AAACjL,YAAM,OAAP;AAAgB2R,aAAOxT,CAAvB;AAA4BoB,YAAM6c;AAAlC,KAAnBnR,GACAhE,EAAc,cAAdA,EAA8BmV,CAA9BnV,EAAwC8D,CAAxC9D,CADAgE;AACwCF,GAf1C/M,GAkBAgG,EAAMqY,YAANrY,GAAqB/F,CAlBrBD,EAmBAiN,GAASgR,CAAThR,EAAwB;AACtBjL,UAAMiI,CADgB;AAEtB1I,UAAMyc,CAFgB;AAGtB1d;AAHsB,GAAxB2M,CAnBAjN,EAwBKkB,SACH8E,EAAM4E,YAAN5E,GAAqB1F,IAChB2d,EAAczX,OAAdyX,GAAwB3d,EAAGyd,CAAHzd,CADRA,GAEjBsK,CAHD1J,CAxBLlB,EA6BOgG,CA/BCkE;AA+BDlE,CDrET;;AGgDO,IAAMwK,KAAQ,CACnBlQ,CADmB,EAEnBgQ,CAFmB,EAGnBhI,CAHmB,KAGnBA;AAAAA;AAAAA,WAGS,CAAC,CAAD,EAAOhI,KAAMgI,CAANhI,CAAP,CAHTgI;AAIE,GAJFA,CAIE,OAAO2G,CAAP,EAAOA;AAAAA,WACPqB,EAASrB,CAATqB,GACO,CAAC,CAAD,EAAQ,IAAR,CAFArB;AAEQ;AAAA,CATZ;AAAA,IAaMoB,KACX,CACE1M,CADF,EAEEiL,CAFF,EAME2B,CANF,EAOEf,CAPF,EAQE1L,CARF,KAUAgC,KACE3C,EAAO;AACLzB,UAAQ,CAAC8N,CAAD,EAAS8O,EAAT,CADH;AAEL3a,UAAQ,CACN4M,IACI;AAACX,YAAQ,MAAT;AAAiBjM,aAAjB;AAAyBlB,YAAQqD;AAAjC,GADJyK,GAEI;AAACX,YAAQ,MAAT;AAAiBjM,aAAjB;AAAyBkM,WAAO/J;AAAhC,GAHE,EAIN;AAAC/E,WAAO+E,CAAR;AAAcxF,QAAIiQ,IAAK3B,EAAIE,EAATyB,GAAc3B,EAAIG;AAApC,GAJM,CAFH;AAQLnL,SAAO,CARF;AASLC,QAAMC,EAAMD,IATP;AAULjC,SAAOmC,GAAYD,CAAZC;AAVF,CAAPZ,CAzBG;;AAsCP,MAAMmb,KAAYjd,EAAW;AAC3BC,QAAM,CAAC8Y,GAAI;AAAC9Z,QAAI;AAAA;AAAEA,aAAF;AAAMS;AAAN;AAAA,aAAiBT,EAAGS,CAAHT,CAAjB;AAAA;AAAL,GAAJ8Z,CAAD,CADqB;AAE3BvY,QAAM;AAAC6O,QAAI,IAAL;AAAWC,QAAI;AAAf;AAFqB,CAAXtP,CAAlB;AAAA,MMhKMqS,KAAqB,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,CNgK3B;AAAA,MM9JME,KAAoB,CAACvM,CAAD,EAAiBsM,CAAjB,KACxBtM,IAAU,KAAIsM,qBN6JhB;;AMzGO,IAAMM,KAAiB,CAC5B5M,CAD4B,EAE5ByM,CAF4B,EAG5BtS,CAH4B,EAI5BqF,CAJ4B,EAK5BnF,CAL4B,EAM5BpB,CAN4B,EAO5BgH,CAP4B,EAQ5BoB,CAR4B,EAS5BqL,CAT4B,EAU5BwK,CAV4B,EAW5BC,CAX4B,EAY5BzQ,CAZ4B,KAY5BA;AAAAA,MAEM0Q,MAAa/c,CAFnBqM;AAGAxN,KACG+J,GAAO9I,CAAP8I,CADH/J,IACUiB,CAAY8I,GAAOwJ,CAAPxJ,CADtB/J,EAEEqT,GAAkBvM,CAAlBuM,EAA0B,wBAA1BA,CAFFrT;AAE4B,MAExBme,IAAgB,CAFQ;AAGxBpU,KAAO9I,CAAP8I,IACFoU,IAAgB,CADdpU,GAEQ9C,EAAQhG,CAARgG,MACVhG,IAASyM,EAAQzM,CAARyM,CADCzG,CAFR8C,EAKAA,GAAOwJ,CAAPxJ,IAEFwJ,IAAQtS,CAFN8I,IAIFyB,GAAc+H,CAAd/H,EAAqB1E,CAArB0E,EAA6B,OAA7BA,GACI/H,MAAMC,OAAND,CAAc8P,CAAd9P,MACF8P,IAAQP,EAAMO,CAANP,CADNvP,CALFsG,CALAA,EAcAoU,MACFld,IAASsS,CADP4K,CAdApU,EAiBC5B,KAAapB,CAAboB,KAAmBpB,IAAO9F,EAAOsG,SAAjCY,CAjBD4B;AAiBkCxC,MAClC6W,IAAqC,MADH7W;AACG,GACrC0W,KAAkB3X,CADmB,MAEnCW,EAAQX,CAARW,IACFmX,IAAa,MADXnX,IAGFjH,EAAO+M,GAAWzG,CAAXyG,CAAP/M,EAA2B,qCAA3BA,GACAoe,IAAa,IAJXnX,CAFmC,GASrC9F,KACFqK,GAAcrK,CAAdqK,EAAsB1E,CAAtB0E,EAA8B,QAA9BA,GACA+I,GAAazN,CAAbyN,EAAqBpT,CAArBoT,CAFEpT,IAKe,WAAfid,CAAe,IACfJ,CADe,IAEf/W,EAAShG,CAATgG,CAFe,IAGfA,EAASsM,CAATtM,CAHe,GAQf9F,IAASiJ,EAHYrK,IACjBA,EAAGgG,GAAQ4G,EAAc1L,CAAd0L,CAAR5G,CAAHhG,EAAmCgG,GAAQ4G,EAAc4G,CAAd5G,CAAR5G,CAAnChG,CADiBA,GAEjBgG,GAAQ4G,EAAc1L,CAAd0L,CAAR5G,CACKqE,EAA0B;AAACrD,WAAD;AAAOyG,UAAP;AAAYpF,QAAID;AAAhB,GAA1BiC,CARM,IAUfjJ,IAASyH,EAAY;AAAC7B,WAAD;AAAOwF,aAAS,CAAhB;AAAsBnE,QAAID;AAA1B,GAAZS,CAATzH,EACAuH,EAAc,cAAdA,EAA8B5E,EAAS3C,CAAT2C,CAA9B4E,CAXe,CAdsB;AAyBEvH,MAKrCkd,IAAa7T,IALwBrJ;AAAAA,MAMvCmd,IAAqB,EANkBnd;;AAMlB,MACN,WAAfid,CADqB,EACE;AAAA,SAClBG,CADkB,EACPC,CADO,IACMC,GAC7BnY,CAD6BmY,EAE7Btd,CAF6Bsd,EAG7BlL,CAH6BkL,EAI7BJ,CAJ6BI,EAK7B3X,CAL6B2X,CADN;AAQzBH,QAAc,IAAII,GAAcF,CAAdE,CAAJ,EAAkBF,GAAeE,GAAcH,CAAdG,CAAjC,CAAdJ;AAA6DC;;AAAAA,OAExDnD,CAFwDmD,EAE7CI,CAF6CJ,IAEhCE,GAC7Bxd,CAD6Bwd,EAE7Btd,CAF6Bsd,EAG7BlL,CAH6BkL,EAI7BJ,CAJ6BI,EAK7B3X,CAL6B2X,CAFgCF;AAO7DzX,SAEFpE,GAAIzB,CAAJyB,EAAY,CACVwH,GACEqJ,CADFrJ,EAEE/I,CAFF+I,EAGE,CACExB,EAAc,oBAAdA,CADF,EAEE6E,GAAI;AAACvM,UAAMwE,CAAP;AAAcrE,YAAQkd;AAAtB,GAAJ9Q,CAFF,EAE4B8Q,GACvBK,GAAcC,CAAdD,CAHL,EAIErR,GAAK+N,CAAL/N,EAAgB,CAAhBA,EAAsBmG,CAAtBnG,CAJF,EAIwBmG,GACnB8K,CALL,EAMEjR,GAAKgR,CAALhR,CANF,EAOiB,SAAf+Q,CAAe,IACbzU,GAAW,CAACiV,CAAD,EAAMzR,CAAN;AAAA,QAAMA;AAAIG;AAAJH,KAAN;AAAA,WAAiB7G,EAAOsY,CAAPtY,EAAYgH,CAAZhH,CAAjB;AAAA,GAAXqD,EAA4C,CAA5CA,CARJ,EASE5J,KAAM4J,GAAW8C,EAAX9C,CATR,EAUEjB,EAAc,oBAAdA,EAAoCwV,CAApCxV,CAVF,CAHFwB,EAeEpD,CAfFoD,EAgBEnK,CAhBFmK,CADU,CAAZxH,GAoBOvB,CAtBL2F;AAsBK3F,CA3GF;;AA8GP,MAAMud,KAAiBvT,KAAoB,CACzCkC,GAAKlC,CAALkC,CADyC,EAEzCvD,GAAK,CAACoD,CAAD,EAAM7L,CAAN;AAAA,MAAMA;AAAQiM;AAARjM,GAAN;AAAA,SAAqBiM,CAArB;AAAA,CAALxD,EAA6B,CAA7BA,CAFyC,CAA3C;AAAA,MAKM2U,KAAkB,CACtBxd,CADsB,EAEtBE,CAFsB,EAGtBoS,CAHsB,EAItB8K,CAJsB,EAKtBvX,CALsB,KAKtBA;AAAAA,MAEM+X,IAAgB5X,EAAShG,CAATgG,CAFtBH;AAAAA,MAGMsU,IAAYyD,IAAgBlS,EAAc1L,CAAd0L,CAAhBkS,GAAwCrU,IAH1D1D;AAAAA,MAIM6X,IAAYnU,GAAeqU,CAAfrU,CAJlB1D;AAIiC+X,SAC5BA,KACH/d,EAAW;AACTP,YAAQU,CADC;AAETF,UAAM,CACJwM,GAAI;AAACvM,YAAMwE,CAAP;AAAcrE,cAAQia;AAAtB,KAAJ7N,CADI,EAEJA,GAAI;AAACvM,Yd1MQ,Oc0MT;AAAcyE,aAAO,CAArB;AAA2BtE,cAAQwd;AAAnC,KAAJpR,CAFI,CAFG;AAMThM,YAAQ;AAACO,cAAQ,CAACb,CAAD,EAASE,CAAT,EAAiBoS,CAAjB,CAAT;AAAkC1R,aAAOV;AAAzC,KANC;AAOTG,UAAM;AAAC6O,UAAIrJ;AAAL,KAPG;AAQTpF,cAAU;AARD,GAAXZ,CADG+d,EAYLnW,EAAc,cAAdA,EAA8BiW,CAA9BjW,EAAyC0S,CAAzC1S,EAAoD2V,CAApD3V,CAZKmW,EAaE,CAACzD,CAAD,EAAYuD,CAAZ,CAd0BE;AAcdF,CA5BrB;AAAA,MGhLM3J,KAAa,CACjBF,CADiB,EAEjB1B,CAFiB,EAGjB7N,CAHiB,EAIjBhC,CAJiB,KAIjBA;AAAAA,MAEMpC,IAAS2T,EAAa1B,CAAb0B,CAFfvR;AAGIpC,OACFyB,EAAO;AACLzB,aADK;AAELiC,YAAQK,MAAMC,OAAND,CAActC,CAAdsC,IAAwBtC,EAAOqI,GAAPrI,CAAW,MAAMoE,CAAjBpE,CAAxBsC,GAAiD8B,CAFpD;AAGLlC,WAAO,CAHF;AAILE;AAJK,GAAPX,CADEzB;AAKAoC,CHoKN;AAAA,MGpKMA,aHoKN;;AGpKMA","names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","regionStack","parent","value","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","stack","getForkPage","Array","isArray","i","length","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","isPure","kernelLoop","deleteMin","idx","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","store","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","pure","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompositeName","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","event","deprecate","oldPage","setCurrentPage","create","graphite","initUnit","watch","watchUnit","map","deriveEvent","MAP","userFnCall","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","createStore","defaultState","props","plainState","createStateRef","updates","createNamedEvent","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","config","lastResult","storeState","innerStore","derived","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","isFunction","updateFilter","defaultConfig","upd","_","b","read","a","mov","sid","setMeta","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createStoreObject","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","kind","use","runner","getCurrent","anyway","finally","done","named","status","error","doneData","failData","handlerId","getType","scope_","handler_","onResolve","onSettled","onReject","ok","runFn","then","op","fx","savedFork","setForkPage","inFlight","x","pending","amount","attach","injected","effect","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","splice","parentDomain","createApi","setters","createDomain","history","hooks","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","Set","res","ownerSet","hook","fromObservable","observable","observableItem","observableSymbol","subscribe","disposer","complete","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","batched","greedy","createSampling","guard","restore","domain","split","targets","METHOD","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","assertTarget","__","splitterSeq","values","caseNames","keys","compute","scopeTargets","String","launchCase","includes","lastValues","needBarrier","storeOrFn","updater","storeRef","caseName","splitterNode","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","visit","normalizeValues","assertEach","fork","domainOrConfig","optiionalConfig","forkInFlightCounter","fxID","batch","resolve","storeStack","storeNode","sidIdMap","sidValuesMap","resultScope","cloneOf","valuesSidMap","hydrate","traverseTarget","needToAssign","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","scopeBind","savedForkPage","serialize","ignoredStores","ignore","onlyChanges","Symbol","__proto__","removeItem","pos","indexOf","push","subject","suggestion","console","graph","val","compositeName","idCount","nextUnitID","nextStepID","readSidRoot","withFactory","loc","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","targetField","cmd","nextBarrierID","run","isEffect","toStack","samplerPriority","isFilter","ref","before","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","newForkPage","newPage","isGetState","sourceRef","isKernelCall","refsMap","isFresh","flattenConfig","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","events","effects","domains","unsubscribe","scopeFn","forward","opts","hookType","configA","configB","isDomain","unitId","thru","observer","nativeTemplate","mapped","caller","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","c","childRef","defaultShape","sidechain","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","filterRef","hasFilter","syncSourceState","readAndFilter","hasSource","src","isSourceStore"],"sources":["/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/collection.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/throw.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/region.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/createNode.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/tag.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/kernel.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/naming.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/config.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/template.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/createUnit.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/combine.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/defer.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/createEffect.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/attach.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/createApi.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/createDomain.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fromObservable.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/merge.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/sample.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/guard.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/restore.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/split.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/allSettled.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/util.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/fork.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/createScope.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/hydrate.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/scopeBind.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/fork/serialize.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/observable.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/validate.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/getter.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/id.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/own.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/is.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/caller.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/step.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/stateRef.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/clearNode.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/subscription.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/forward.ts","/Users/s.shakirova/Desktop/GitHub/device-github/node_modules/effector/effector/watch.ts"],"sourcesContent":["export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value\n  template\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]}\n  meta?: {[name: string]}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value\n  a\n  b\n  c?\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?, upsert?: boolean): void\nexport function launch(unit, payload?, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args): [any[], any | void]\nexport function processArgsToConfig(\n  args,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part, config = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event, CommonUnit, Effect} from './unit.h'\n\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\nimport type {Template} from '../forest/index.h'\n\nexport const applyParentHook = (\n  source,\n  target,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind, unit, configA, configB?) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : upd => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event, op: string, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName}  *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?,\n  maybeConfig?,\n): Event<Payload> {\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('*  ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName}  *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch(payload => fn(store.getState(), payload))\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (getMeta(store, 'serialize') !== 'ignore')\n      setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  assert(\n    getMeta(store, 'derived') || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = list => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj,\n  config?: Config,\n  fn?: (upd) => any,\n) => {\n  const clone = isArray ? list => list.slice() : obj => ({...obj})\n  const defaultState = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value) => any\n  rj: (value) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value) => any\n    rj: (value) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import type {Unit} from './index.h'\nimport type {Effect} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done, Fail = Error>(\n  nameOrConfig,\n  maybeConfig?,\n): Effect<Payload, Done, Fail> {\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  ) as unknown as Effect<Payload, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data) {}, rj(data) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data) => void,\n  args,\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params,\n    req: {\n      rs(_)\n      rj(_)\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  data =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    //@ts-expect-error\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig, maybeConfig?): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  own(source, [\n    createLinkNode(\n      clock,\n      target,\n      [\n        applyTemplate('sampleSourceLoader'),\n        mov({from: STACK, target: clockState}),\n        ...readAndFilter(hasSource),\n        read(sourceRef, true, batched),\n        ...filterNodes,\n        read(clockState),\n        filterType === 'fn' &&\n          userFnCall((src, _, {a}) => filter(src, a), true),\n        fn && userFnCall(callStackAReg),\n        applyTemplate('sampleSourceUpward', isUpward),\n      ],\n      method,\n      fn,\n    ),\n  ])\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj, defaultState, config?) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch, Stack} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\nexport function allSettled(\n  start,\n  {scope, params: ctx}: {scope: Scope; params?},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits = [start]\n  const launchParams = [] as Array<{params; req} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value) {\n              //@ts-expect-error\n              defer.value = {status: 'done', value}\n            },\n            rj(value) {\n              //@ts-expect-error\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key, value) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?; handlers?},\n  optiionalConfig?: {values?; handlers?},\n) {\n  let config: {values?; handlers?} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack && getParent(storeStack)) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            getMeta(getParent(storeStack).node, 'op') !== 'combine'\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? params => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : params => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = obj => (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => obj => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value) => value is Store<unknown>\nexport const event = is(EVENT) as (value) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value) => value is Domain\nexport const scope = is(SCOPE) as (value) => value is Scope\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = stack => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = unit => unit.parent\nexport const getForkPage = (val): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport {getMeta} from './getter'\n\nexport const isObject = value => typeof value === 'object' && value !== null\nexport const isFunction = value => typeof value === 'function'\n\nexport const isVoid = value => value === undefined\n\nexport const assertObject = value =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (value, method: string, valueName: string) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data, scope: {[key: string]}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data, scope: {[key: string]}, stack: Stack)\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({fn}: {fn(data, scope: {[key: string]}, stack: Stack)}) =>\n  compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}